{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"today",
				"today_formatted"
			],
			[
				"arr",
				"arr_values"
			],
			[
				"arr_all",
				"arr_all"
			],
			[
				"tree_values",
				"tree_values_tuple"
			],
			[
				"date_issed",
				"date_issued_list"
			],
			[
				"date_issued",
				"date_issued_list"
			],
			[
				"Main",
				"MainApplication"
			],
			[
				"email_add",
				"email_address_list"
			],
			[
				"email_address",
				"email_address_fetch"
			],
			[
				"time",
				"time_remaining"
			],
			[
				"empty",
				"empty_list"
			],
			[
				"password_str",
				"password_strength_container_1"
			],
			[
				"password_sten",
				"password_strength_label_2"
			],
			[
				"global",
				"global_frame"
			],
			[
				"sign",
				"sign_in_notebook"
			],
			[
				"change_pass",
				"change_password_button_container"
			],
			[
				"change_password",
				"change_password_container"
			],
			[
				"show",
				"showinfo"
			],
			[
				"ret_search",
				"ret_search_container_canvas"
			],
			[
				"email_",
				"email_input"
			],
			[
				"boo",
				"book_owner\tlist ⟠"
			],
			[
				"right",
				"RIGHT"
			],
			[
				"ret_",
				"ret_title_var"
			],
			[
				"book",
				"book_id_search\t⟠"
			],
			[
				"tab",
				"notebook_tab_change"
			],
			[
				"libr",
				"Library"
			],
			[
				"aCCOUNT",
				"Accounts"
			],
			[
				"my",
				"mybooks_tv"
			],
			[
				"Update",
				"UpdateLibraryTV"
			],
			[
				"user_em",
				"current_user_email"
			],
			[
				"account",
				"account_mybooks_check"
			],
			[
				"fro",
				"FROM"
			],
			[
				"text",
				"textvariable"
			],
			[
				"variable",
				"variable_declaration"
			],
			[
				"get",
				"get_date"
			],
			[
				"set",
				"set_date"
			],
			[
				"search",
				"search_container"
			],
			[
				"Librar",
				"LibrarySystem"
			],
			[
				"signin",
				"sign_in_notebook"
			],
			[
				"sign_in",
				"sign_in_notebook"
			],
			[
				"Register",
				"RegisterLogin"
			],
			[
				"login",
				"login_page"
			],
			[
				"selection",
				"selection_set(…)\tfunction ⟠"
			],
			[
				"dumm",
				"dummy_data_temp_2\tlist ⟠"
			],
			[
				"d",
				"dummy_data_temp_2\tlist ⟠"
			],
			[
				"top",
				"TOP\tstr ⟠"
			],
			[
				"account_container",
				"account_container_header\tLabel ⟠"
			],
			[
				"grid_",
				"grid_columnconfigure(…)\tfunction ⟠"
			],
			[
				"notebook",
				"main_notebook"
			],
			[
				"Req",
				"RequestResetForm"
			],
			[
				"Regist",
				"RegistrationForm"
			],
			[
				"Pass",
				"PasswordField"
			],
			[
				"R",
				"RequestResetForm\ttype ⟠"
			],
			[
				"Text",
				"TextAreaField\ttype ⟠"
			],
			[
				"datetime",
				"datetime\ttype ⟠"
			],
			[
				"Email",
				"email_validator\t⟠"
			],
			[
				"password",
				"password"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "'''\n- Requirements:\n        - Database to store all relevant fields for the book information\n        - Database to store all relevant issuer's information\n        - UI for library staff to update book database (if new books come in/out)\n        - UI for library staff to issue out a book\n        - UI for users to look at the available books\n        - Set a return date based on the day they took the book out.\n        - Allow library staff to set return date manually\n        - Send email alert if book has not been returned (optional)\n\nIdeas Up for Debate:\n    - Date of Return can be chosen by the staff or be a fixed amount (currently 2 weeks)\n    - \n    -\n    -\n    -\n'''\n\n# UPDATE 02/08/2020\n# - FIXED DATABASE ISSUES REGARDING MyBooks page displaying incorrect information HUGE ISSUE EZY CLAP\n# - NEXT STEP: ALLOW STAFF TO RETRIEVE USER BOOK (would involve making the 'issued' field in the Books table 0 instead of 1 when it has been turned in) DONE\n\n# UPDATE 03/08/2020\n# - ADDED RETURN BOOK FUNCTIONALITY AS NEEDED ABOVE.\n# - REQUIRED FIXES: UPDATE TREEVIEWS ACCORDING TO THE BOOK RETURN. <--- STILL ON THIS. Nope\n# - NEXT STEP: ALLOW ADMIN ACCOUNTS TO INTRODUCE NEW BOOKS INTO THE SYSTEM.\n# - REMEMBER TO RESET DB BECAUSE THERE IS A NEW FIELD (return_date) AND BECAUSE I MESSED AROUND WITH SOME VALUES.\n\n\n# UPDATE 09/08/2020\n# - FIXED TREEVIEWS NOT UPDATING UPON ISSUE/RETURN\n# - REQUIRED FIXES: AUTOCOMPLETE BOX NOT FETCHING UPDATED DATABASE TABLES AFTER A BOOK ISSUE/RETURN\n\n# UPDATE 02/09/2020\n# - FIXED MY BOOKS TREEVIEW NOT UPDATING (ADDED REFRESH TREEVIEW BUTTON)\n# - REQUIRED FIXES: AUTOCOMPLETE BOX (ON BOOK DATABASE CLASS) NOT FETCHING UPDATED DATABASE TITLES AFTER A BOOK ISSUE/RETURN, HOWEVER IT FIXES ITSELF AFTER A RESTART/ CAUSED BY PRESSING RETURN/ISSUE BUTTON;\n#                   AUTOCOMPLETE BOX (ON BOOK DATABASE CLASS) APPEARING TWICE UPON ISSUE/RETURN BUTTON BEING PRESSED\n#                   AUTOCOMPLETE FILTER BOX (ON MY BOOKS CLASS) SHOWING ALL BOOKS RATHER USER'S BOOKS.\n\n# UPDATE 03/09/2020 AND 04/09/2020\n# - FIXES:\n#       - AUTOCOMPLETE BOX (ON BOOK DATABASE CLASS) NOT FETCHING UPDATED DATABASE TITLES AFTER A BOOK ISSUE/RETURN, HOWEVER IT FIXES ITSELF AFTER A RESTART/ CAUSED BY PRESSING RETURN/ISSUE BUTTON;\n#       - AUTOCOMPLETE BOX (ON BOOK DATABASE CLASS) APPEARING TWICE UPON ISSUE/RETURN BUTTON BEING PRESSED\n#       - AUTOCOMPLETE FILTER BOX (ON MY BOOKS CLASS) SHOWING ALL BOOKS RATHER USER'S BOOKS.\n\n#       - AUTOCOMPLETE IS NOW INDEPENDENT FOR EACH ENTRY BOX. HOWEVER, IF YOU SELECT AN AUTOCOMPLETE OPTION,\n#         THE OTHERS WILL TRIGGER AND YOU WONT BE ABLE TO CLOSE ALL THE AUTOCOMPLETE BOXES.\n#       - FIXED BY REMOVING ALL AUTOCOMPLETE BOXES EXCEPT FOR THE BOOKID FIELD.\n#\n# - REQUIRED FIXES/ADDITIONS:\n#       - ALLOW BOOKS TO BE ISSUED BY THEIR bookID - COMPLETE\n#       - ALLOW STAFF TO INTRODUCE NEW BOOKS/REMOVE MISSING BOOKS FROM THE DATABASE. - COMPLETE\n#       - ALLOW LIBRARY AND MY BOOKS PAGE TO BE SEARCHED BY bookID - COMPLETE\n#       - SHOW bookID COLUMN ON THE TREEVIEW TABLES. - COMPLETE\n\n# UPDATE 05/09/2020\n# - QUALITY OF LIFE ADDITIONS/FIXES:\n#       - FOCUS SIGN IN PAGE ONTO THE LOGIN BOX (so that the user can start typing their email immediately) - COMPLETE\n#       - ALLOW <Return> BUTTON TO LOGIN/REGISTER THE USER AMONG OTHER PLACES WHERE PRESSING <Return> FEELS NATURAL TO COMPLETE A TASK - COMPLETE\n#       - MOVE SOME OF THE FILTER FRAMES CLOSER TO THE TREEVIEWS FOR EASIER ACCESS AND INTERPRETATION - COMPLETE\n#       - DON'T ALLOW STAFF TO CHANGE THE DATE OF ISSUING/RETURN ON THE BOOK DATABASE PAGE\n#       - INPUT VALIDATION SO THAT INCORRECT/INVALID DATA CANNOT BE ENTERED INTO MANY FIELDS LIKE THE ISSUE/RETURN BOOKS PAGE\n#       - ADD A FEW CUSTOMISATION OPTIONS ONTO THE OPTIONS PAGE\n#       - FIND USE FOR HOME PAGE OR REMOVE IT AND MAKE THE DEFAULT PAGE UPON LOGIN THE LIBRARY PAGE.\n#       - MOVE THE AUTOCOMPLETE BOX TO A MORE ADEQUATE LOCATION - COMPLETE\n#       - FIND A WAY TO FETCH THE LOWEST AVAILABLE BOOK IDS THAT ARE NOT BEING USED, DUE TO THEM BEING REMOVED PREVIOUSLY. FIND VACANT BOOKIDS IF YOU WILL. - NOT NEEDED ANYMORE\n#       - ALLOW STAFF TO ADD NEW GENRES TO THE OptionMenu - HALFWAY THROUGH THIS - COMPLETE\n\n# UPDATE 06/09/2020\n#       - MAKE ALL DATE ENTRIES THE SAME FORMAT (UK FORMAT DD/MM/YYYY) - COMPLETE\n#       - FIX ENCRYPTED PASSWORD SHTICK\n#\n#       - DISALLOW USERS FROM TAKING OUT THE SAME BOOK MULTIPLE TIMES, SO IF I HAVE A BOOK WITH THE bookID = 1, THAT BOOK CANNOT BE ISSUED OUT ANYMORE. -COMPLETE\n#\n#       - INPUT VALIDATION FOR THE FOLLOWING:\n#             - BOOKID FILTER IN MYBOOKS MUST BE INTEGERS ONLY - COMPLETE\n#             - BOOKID SEARCH IN LIBRARY MUST BE INTEGERS ONLY - COMPLETE\n#             - BOOKID SEARCH IN ISSUE BOOK, RETURN BOOK AND REMOVE BOOK FROM SYSTEM MUST BE INTEGERS ONLY - COMPLETE\n#             - DATE OF ISSUED/DATE OF RETURN MUST HAVE A DATE THAT HASNT ALREADY GONE BY\n#             - GENRE NAME IN ADD BOOK INTO SYSTEM IN BOOK DB PAGE MUST NOT HAVE NUMBERS \n\n# UPDATE 07/09/2020\n# - FIXES:\n#       - Dates now show in UK format.\n# - TODO:\n#       - Fix password encryption.\n#       - CONCEPT: Make section in BookDB page that allows staff to search the treeview below. - COMPLETED\n#       - Connect Email Functionality to the software:\n#                   - Add Functionality to the Send Request button on the Forgot Password? Page at the application startup.\n#                   - Add Functionality to the Change Password? button on the Account page whilst logged in\n#                   - Add email notification that is sent out upon book being issued to said recipients' email.\n#                   - Add email notification that is sent out upon book being returned to said recipients' email.\n#                   - Add email notification that is sent out upon return date being passed. *CONCEPT, MAY BE HARD*\n#\n#       - Allow user to sort treeview tables by pressing the column headers *CONCEPT*\n#       - Add Options Page Functionality to the software, allowing the user to customise/change:\n#                   - Background Colours\n#                   - Foreground Colours\n#                   - Fonts\n#                   - More to come etc...\n#       - Add ttk.Style to make design more sleek\n#\n\n# UPDATE 16/09/2020\n# - FIXES:\n#       - ADDED ABILITY TO SEARCH THE BOOKDB PAGE TREEVIEW BY ANY FIELD FROM BOOKID TO ISSUED STATE.\n# - TODO:\n#       - Fix 'Date of Return' field on Return Book container in Book Database Page.\n#       - Decide what happens with the font stuff. Either all widgets have font field or none.\n#       - Add ttk.Style to make design more sleek (Needs to be explored, never used before.)\n#       - Check ttk.Style possible issues\n#       - 'Return Book' button text is slightly shifted down when the autocomplete box is dragged down. investigate\n#       - Allow admin to assign other admin accounts (staff accounts) to new employees.\n#\n\n# UPDATE 29/09/2020\n# - FIXES:\n#       - DATABASE NOW STORES PASSWORDS USING A HASHING ALGORITHM AND SALT\n# - TODO:\n#       - ALL ISSUE/RETURN buttons get pushed down outside the frame. /FIXED\n#       - ERROR: ValueError: time data '13/10/2020' does not match format '%Y-%m-%d' when a is entered into issue date box /FIXED\n#       - autocomplete box is being packed below issue/return button after being forgotten. /FIXED\n#       - Genre list in the database needs to be updated to have all the correct genres stored. /FIXED\n#       - When removing book, remove any links it has to any users (idk if ive covered this yet) /already fixed previously\n#       - Add prompt feedback when pressing the buttons to let user know the action has gone through. /ADDED\n#\n#       - Set register details to empty strings after registration and automatically redirect the user to the login page. /ADDED\n#       - Add logout feature (always in the top corner? or on the account page?) /ADDED\n#       - Add account deletion feature on Account page /ADDED\n#       - Add functionality to Change Password part in Accounts page. /ADDED\n#       - Add the thing that shows how strong the password is upon registration /DONE\n#       - Add ability to see their own password with a toggle button /DONE\n#       - Added Restrictions on password using regex. /DONE? I THINK?\n#       \n#       - Add location of book in the library in the database. (MAY REQUIRE DATABASE RECONFIGURATION AND WILL CHANGE THE SCOPE OF THE PROJECT SLIGHTLY IN THE WORD DOCUMENT)\n#       - Only allow user to remove a genre if its not in use by any other books. /DONE\n#       - Add feature to allow staff accounts to add other staff accounts to the database.\n#       - Compact repeated code into functions to make code a bit less overwhelming\n#       \n#       - Find a way to implement Quicksort into this.\n#       - The autofill algorithm should display what fields its going to fill in the title, author and all that before a selection is made, rather than just show the bookID that tells the staff nothing at first glance.\n#\n#\n#       cba to update log (06/11/20) but i need to fix the send request function a bit. good stuff tho\n#\n# - TODO:\n#       - Validate BookID entry on \"Add Book into System\" section/DONE\n#       - No option showing up for \"-EMPTY-\" genre on\" Add Book Into System\" section/DONE\n#       - \"Issue Book\" section labels have \"Book\" before their respective entries, remove that./DONE\n#       - \"Issue date\" and \"return date\" is not being saved to the MyBooks page/DONE\n#       - \"location\" is not being saved to the \"Books\" table./DONE\n#       - Search by genre on BookDatabase page at the bottom does not show \"-EMPTY-\" as an option./DONE\n#       - No option showing up for \"-EMPTY-\" genre on \"Remove Book From System\" section/DONE\n#       - No books showing up on the Library treeview/DONE\n#       - No books showing up on the MyBooks treeview/DONE\n#       - MyBooks filter section, the genre optionmenu does not show the \"-EMPTY-\" option/DONE\n#        \n# - TODO: (07/11/20)\n#       - Treeview sorting algorithm using quicksort (already works with what i have, but it isnt coursework. I want to apply it for more marks) /DONE (Needs tweaking so that when the filters are put on it can filter within that.)\n#       - Autocomplete book with all fields in the issue book, return book and remove book sections\n#       - Send emails regarding return dates as they draw near. (Admin button to send out alerts that are nearing perhaps)\n#       - Complete analytics side of admin page with numpy maybe and other graphs\n#       - Make Filters on Library and MyBooks work together to find a value. (optimising the filters)\n#       - Add filters using tkCalendar to allow the staff to search by return date or issue date. The same applies to the MyBooks page where the user can search the treeview based on a return/issue date using a filter.\n#       -\n#       -\n#       -\n#       -\n#       -\n#       -\n#       -\n#       -\n#       -\n#       -\n#\n\nimport tkinter as tk\nfrom tkinter import ttk\nimport re\nfrom tkinter import messagebox as ms\nimport sys\nimport bcrypt\nimport sqlite3\nfrom tkcalendar import DateEntry\nfrom datetime import datetime, timedelta\nimport base64\nimport logging\nimport mimetypes\nimport os\nimport os.path\nimport pickle\nfrom email.mime.text import MIMEText\nfrom google_auth_oauthlib.flow import InstalledAppFlow\nfrom google.auth.transport.requests import Request\nfrom googleapiclient import errors\nfrom googleapiclient.discovery import build\nfrom bs4 import BeautifulSoup\nimport random\nimport secrets\nimport string\n\nconn = sqlite3.connect('LibrarySystem.db')\nc = conn.cursor()\n\nglobal firstRun\nfirstRun = True\nwidth=225\npadx=8\npady=5\n\ngeometry = '1500x1500'\nbg='gray90'\nfont='System 18'\n\n#List of genres\nc.execute(\"SELECT genre FROM Genres\")\ngenres_list_fetch = c.fetchall()\ngenre_choice_list = [x[0] for x in genres_list_fetch]\n\n#Fetch database values\n#Titles that have not been issued (issued=0) \nc.execute(\"SELECT title FROM Books WHERE issued=0\")\nbooks_title_fetch = c.fetchall()\nbook_title_list = [x[0] for x in books_title_fetch]\n\n#Fetch database books that have been issued (issued=1)\n#Titles\nc.execute(\"SELECT title FROM Books WHERE issued=1\")\nissued_titles_fetch = c.fetchall()\nissued_titles = [x[0] for x in issued_titles_fetch]\n\n#List of locations\nlocation_choice_list = list(string.ascii_uppercase)\nlocation_alphabet_symbol = location_choice_list.append('*')\nlocation_empty_insert = location_choice_list.insert(0, '-EMPTY-')\n\n#List of issued\nissued_choice_list = ['-EMPTY-', '0', '1']\n\n\nclass Options():\n    #USER ACCESS\n    #Display program options (Theme, Font, etc...)\n    #Optionally do this. Leave for now.\n    def __init__(self, root, notebook):\n        option_page = tk.Frame(notebook)\n        notebook.add(option_page, text='Options')\n\n        options_header = tk.Label(option_page, text='Options', font='System 30')\n        options_header.pack(side=tk.TOP)\n\n        #Options Main Container\n        options_container = tk.Frame(option_page, bg=bg)\n        options_container.pack(side=tk.LEFT, anchor=tk.N, padx=padx)\n\n        #Font Choice\n        self.options_container_font = tk.Frame(options_container, bg=bg)\n        self.options_container_font.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        font_label = tk.Label(self.options_container_font, text='Choose a Font: ', bg=bg)\n        font_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.font_list = [\"System\", \"Helvetica\", \"Arial\", \"Times\", \"Courier\", \"Palatino\", \"Garamond\", \"Bookman\", \"Avant\"]\n\n        self.font_list_var = tk.StringVar()\n        self.font_list_var.set(self.font_list[0])\n        self.font_list_var.trace(\"w\", self.font_global_change)\n\n        self.font_listbox = ttk.OptionMenu(self.options_container_font, self.font_list_var, *self.font_list)\n        self.font_listbox.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n    def font_global_change(self, *args):\n        global global_font\n        global_font = self.font_list_var.get()\n\n\n\nclass Admin():\n    #ADMIN ACCESS ONLY (NO STAFF OR REGULAR USERS ALLOWED)\n    #Allows library admin(s) to create accounts for the staff.\n    #Displays analytical data for the admin users to read from.\n    def __init__(self, root, notebook, user_email):\n        self.root = root\n        self.notebook = notebook\n\n        admin_page = tk.Frame(self.notebook)\n        notebook.add(admin_page, text=\"Admin\")\n\n        header_frame = tk.Frame(admin_page)\n        header_frame.pack(fill=tk.X, side=tk.TOP)\n\n        header = tk.Label(header_frame, text=\"Admin\", font='System 30')\n        header.pack(side=tk.TOP)\n\n        #Add Staff Account\n        add_account_container = tk.Frame(admin_page, bg=bg)\n        add_account_container.pack(side=tk.LEFT, anchor=tk.N, padx=padx, pady=pady)\n\n        add_account_header = tk.Label(add_account_container, text='Add Account', font='System 18', bg=bg)\n        add_account_header.pack(anchor=tk.W, padx=padx, pady=pady)\n\n        #User ID Field\n        self.userID_container = tk.Frame(add_account_container, bg=bg)\n        self.userID_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        userID_label = tk.Label(self.userID_container, text='User ID: ', bg=bg)\n        userID_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.userID_var = tk.StringVar()\n        #set the variable to +1 the highest userID in the database to make a new account on that record.\n        self.userID_var.set('')\n\n        self.userID_entry = ttk.Entry(self.userID_container)\n        self.userID_entry.config(textvariable=self.userID_var, state=tk.DISABLED)\n        self.userID_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        #Email Address Entry Field\n        self.email_container = tk.Frame(add_account_container, bg=bg)\n        self.email_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        email_label = tk.Label(self.email_container, text='Email Address: ', bg=bg)\n        email_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.email_var = tk.StringVar()\n\n        self.email_entry = ttk.Entry(self.email_container, textvariable=self.email_var)\n        self.email_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        #Password Entry Field\n        self.password_container = tk.Frame(add_account_container, bg=bg)\n        self.password_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        password_label = tk.Label(self.password_container, text='Password: ', bg=bg)\n        password_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.password_var = tk.StringVar()\n\n        self.password_entry = ttk.Entry(self.password_container, textvariable=self.password_var)\n        self.password_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Password Entry Field\n        self.confirm_password_container = tk.Frame(add_account_container, bg=bg)\n        self.confirm_password_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        confirm_password_label = tk.Label(self.confirm_password_container, text='Confirm Password: ', bg=bg)\n        confirm_password_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.confirm_password_var = tk.StringVar()\n\n        self.confirm_password_entry = ttk.Entry(self.confirm_password_container, textvariable=self.confirm_password_var)\n        self.confirm_password_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Add Account\n        add_account_button_container = tk.Frame(add_account_container, bg=bg)\n        add_account_button_container.pack(anchor=tk.W, fill=tk.X, expand=True)\n\n\n        add_account_btn = ttk.Button(add_account_button_container)\n        add_account_btn.config(text='    Add Account    ', command=self.add_account)\n        add_account_btn.pack(side=tk.RIGHT, anchor=tk.W, padx=padx, pady=pady)\n\n\n\n\n\n         #Add Staff Account\n        remove_account_container = tk.Frame(admin_page, bg=bg)\n        remove_account_container.pack(side=tk.LEFT, anchor=tk.N, padx=padx, pady=pady)\n\n        remove_account_header = tk.Label(remove_account_container, text='Remove Account', font='System 18', bg=bg)\n        remove_account_header.pack(anchor=tk.W, padx=padx, pady=pady)\n\n        #User ID Field\n        self.remove_userID_container = tk.Frame(remove_account_container, bg=bg)\n        self.remove_userID_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        remove_userID_label = tk.Label(self.remove_userID_container, text='User ID: ', bg=bg)\n        remove_userID_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.remove_userID_var = tk.StringVar()\n        #set the variable to +1 the highest userID in the database to make a new account on that record.\n        self.remove_userID_var.set('')\n\n        self.remove_userID_entry = ttk.Entry(self.remove_userID_container)\n        self.remove_userID_entry.config(textvariable=self.remove_userID_var, state=tk.DISABLED)\n        self.remove_userID_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        #Email Address Entry Field\n        self.remove_email_container = tk.Frame(remove_account_container, bg=bg)\n        self.remove_email_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        remove_email_label = tk.Label(self.remove_email_container, text='Email Address: ', bg=bg)\n        remove_email_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.remove_email_var = tk.StringVar()\n\n        self.remove_email_entry = ttk.Entry(self.remove_email_container, textvariable=self.remove_email_var)\n        self.remove_email_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Remove Account\n        remove_account_button_container = tk.Frame(remove_account_container, bg=bg)\n        remove_account_button_container.pack(anchor=tk.W, fill=tk.X, expand=True)\n\n\n        remove_account_btn = ttk.Button(remove_account_button_container)\n        remove_account_btn.config(text='    Remove Account    ', command=self.remove_account)\n        remove_account_btn.pack(side=tk.RIGHT, anchor=tk.W, padx=padx, pady=pady)\n\n\n\n\n\n\n\n        #Update Existing Account\n        #Allows an admin to update the permissions of a staff/user account.\n        update_account_container = tk.Frame(admin_page, bg=bg)\n        update_account_container.pack(side=tk.LEFT, anchor=tk.N, padx=padx, pady=pady)\n\n        update_account_header = tk.Label(update_account_container, text='Update Account', font='System 18', bg=bg)\n        update_account_header.pack(anchor=tk.W, padx=padx, pady=pady)\n\n        #UserID Entry Field\n        self.update_account_userID_container = tk.Frame(update_account_container, bg=bg)\n        self.update_account_userID_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        update_userID_label = tk.Label(self.update_account_userID_container, text='User ID: ', bg=bg)\n        update_userID_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.update_userID_var = tk.StringVar()\n\n        self.update_userID_var = ttk.Entry(self.update_account_userID_container)\n        self.update_userID_var.config(textvariable=self.update_userID_var, state=tk.DISABLED)\n        self.update_userID_var.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Email Address Entry Field\n        self.update_account_email_container = tk.Frame(update_account_container, bg=bg)\n        self.update_account_email_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        update_email_label = tk.Label(self.update_account_email_container, text='Email Address: ', bg=bg)\n        update_email_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.update_email_var = tk.StringVar()\n\n        self.update_email_entry = ttk.Entry(self.update_account_email_container, textvariable=self.update_email_var)\n        self.update_email_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Update staff mode frame\n        update_mode_container = tk.Frame(update_account_container, bg=bg)\n        update_mode_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        update_mode_label = tk.Label(update_mode_container, text='Staff Mode: ', bg=bg)\n        update_mode_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.staff_mode_var = tk.IntVar()\n\n        staff_mode_checkbtn = ttk.Checkbutton(update_mode_container, variable=self.staff_mode_var)\n        staff_mode_checkbtn.pack(side=tk.LEFT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Update Account Button\n        update_account_button_container = tk.Frame(update_account_container, bg=bg)\n        update_account_button_container.pack(anchor=tk.W, fill=tk.X, expand=True)\n\n        update_account_btn = ttk.Button(update_account_button_container)\n        update_account_btn.config(text='    Update Account    ', command=self.update_account)\n        update_account_btn.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n\n\n        #Analytical Information\n        analytics_container = tk.Frame(admin_page, bg=bg)\n        analytics_container.pack(side=tk.LEFT, anchor=tk.N, padx=padx, pady=pady)\n\n        analytics_header = tk.Label(analytics_container, text='Analytics', font='System 18', bg=bg)\n        analytics_header.pack(anchor=tk.W, padx=padx, pady=pady, expand=True, fill=tk.BOTH)\n        \n\n\n        #Analytical graphs will be created using numpy or something alike. This will be a great opportunity to use quicksort to sort a table of data values for the user.\n        #There will be buttons that open TopLevels that show the information regarding its topic accordingly.\n\n        #Types of data we could include here:\n        #   - Number of user accounts\n        #   - Number of staff accounts\n        #   - Number of admin accounts\n        #   - Total book tally\n        #   - Total issued book tally\n        #   - Total Non-Issued book tally\n        #   - Ratio of successfully returned books to books that have been issued and not returned (more complex)\n        #   - Average number of days before return\n        #   - Average number of books issued out on a single day\n        #\n\n    def add_account(self):\n        pass\n\n    def update_account(self):\n        pass\n\n    def remove_account(self):\n        pass\n    # def password_strength(self, *args):\n    #     special_characters_regex = re.compile(\"\"\"[!@#$%^*-_+=|\\\\\\{\\}\\[\\]`¬;:@\"'<>,./?]\"\"\")\n    #     password_input = self.user_password_var.get()\n\n    #     if len(password_input) >= 8:\n    #         self.password_strength_container_1.pack_forget()\n    #         if special_characters_regex.search(password_input) != None :\n    #             self.password_strength_container_2.pack_forget()\n    #         else:\n    #             self.password_strength_container_2.pack(expand=True)\n\n    #     elif len(password_input) < 8:\n    #         self.password_strength_container_1.pack(expand=True)\n    #         if special_characters_regex.search(password_input) != None :\n    #             self.password_strength_container_2.pack_forget()\n    #         else:\n    #             self.password_strength_container_2.pack(expand=True)\n\n    # def show_password(self, *args):\n    #     if self.password_entry[\"show\"] == \"*\":\n    #         self.password_entry[\"show\"]=''\n    #         self.confirm_pw_entry[\"show\"]=''\n    #     else:\n    #         self.password_entry[\"show\"]='*'\n    #         self.confirm_pw_entry[\"show\"]='*'\n\n\n\n\n\n\n\nclass BookDatabase():\n    #STAFF ONLY ACCESS\n    #Update book database when books are taken in/out.\n    def __init__(self, root, notebook, current_user_email):\n        self.tree_ids = [] \n        self.lista = []\n        self.root = root\n        self.notebook = notebook\n        user_email = current_user_email\n\n        book_database_page = tk.Frame(self.notebook)\n        notebook.add(book_database_page, text='Book Database')\n\n        header_frame = tk.Frame(book_database_page)\n        header_frame.pack(fill=tk.X, side=tk.TOP)\n\n        header = tk.Label(header_frame, text='Book Database', font='System 30')\n        header.pack(side=tk.TOP)\n\n        # Library TreeView Book Database Frame\n        tree_container = tk.Frame(book_database_page, bg=bg)\n        tree_container.pack(side=tk.BOTTOM, anchor=tk.N, padx=padx, pady=pady)\n\n        tree_header = tk.Label(tree_container, text='Database', font='System 18', bg=bg)\n        tree_header.pack(padx=padx, pady=pady)\n\n        #Set up TreeView table\n        self.columns = ('Book ID','Title', 'Author', 'Genre','Location', 'Issued', 'Issue Date', 'Return Date')\n        self.tree = ttk.Treeview(tree_container, columns=self.columns, show='headings') #create tree\n        self.tree.heading(\"Book ID\", text='Book ID')\n        self.tree.heading(\"Title\", text='Title')\n        self.tree.heading(\"Author\", text='Author')\n        self.tree.heading(\"Genre\", text='Genre')\n        self.tree.heading(\"Location\", text='Location')\n        self.tree.heading(\"Issued\", text='Issued')\n        self.tree.heading(\"Issue Date\", text='Issued Date')\n        self.tree.heading(\"Return Date\", text='Return Date')\n\n        self.tree.column(\"Book ID\", width=width, anchor=tk.CENTER)\n        self.tree.column(\"Title\", width=width, anchor=tk.CENTER)\n        self.tree.column(\"Author\", width=width, anchor=tk.CENTER)\n        self.tree.column(\"Genre\", width=width, anchor=tk.CENTER)\n        self.tree.column(\"Location\", width=width, anchor=tk.CENTER)\n        self.tree.column(\"Issued\", width=width, anchor=tk.CENTER)\n        self.tree.column(\"Issue Date\", width=width, anchor=tk.CENTER)\n        self.tree.column(\"Return Date\", width=width, anchor=tk.CENTER)\n\n        #Book IDs\n        c.execute(\"SELECT bookID FROM Books\")\n        bookIDs_fetch = c.fetchall()\n        bookID_list = [x[0] for x in bookIDs_fetch]\n\n        #Titles\n        c.execute(\"SELECT title FROM Books\")\n        title_fetch = c.fetchall()\n        title_list = [x[0] for x in title_fetch]\n\n        #Authors\n        c.execute(\"SELECT author FROM Books\")\n        author_fetch = c.fetchall()\n        author_list = [x[0] for x in author_fetch]\n\n        #Genres\n        c.execute(\"SELECT genre FROM Books\")\n        genre_fetch = c.fetchall()\n        genre_list = [x[0] for x in genre_fetch]\n\n        #location\n        c.execute(\"SELECT location FROM Books\")\n        location_fetch = c.fetchall()\n        location_list = [x[0] for x in location_fetch]\n\n        #Issued/Not Issued\n        c.execute(\"SELECT issued FROM Books\")\n        issued_fetch = c.fetchall()\n        issued_list = [x[0] for x in issued_fetch]\n\n        for k in self.tree.get_children():\n            self.tree.delete(k)\n\n        for i in range(len(bookID_list)):\n            #Issue Date\n            c.execute(\"SELECT date_issued FROM MyBooks WHERE my_booksID=(SELECT my_booksID WHERE bookID=?)\",(bookID_list[i],))\n            date_issued_fetch = c.fetchall()\n            date_issued_list = [x[0] for x in date_issued_fetch]\n\n            #Return Date\n            c.execute(\"SELECT return_date FROM MyBooks WHERE my_booksID=(SELECT my_booksID WHERE bookID=?)\",(bookID_list[i],))\n            return_date_fetch = c.fetchall()\n            return_date_list = [x[0] for x in return_date_fetch]\n            #creates an entry in the tree for each element of the list\n            #then stores the id of the tree in the self.ids list\n            if len(date_issued_list)==0 or len(return_date_list)==0:\n                self.tree_ids.append(self.tree.insert(\"\", \"end\", values=(bookID_list[i], title_list[i], author_list[i], genre_list[i], location_list[i], issued_list[i], 'N/A', 'N/A')))\n            else:\n                self.tree_ids.append(self.tree.insert(\"\", \"end\", values=(bookID_list[i], title_list[i], author_list[i], genre_list[i], location_list[i], issued_list[i], date_issued_list[0], return_date_list[0])))\n        self.tree.pack()\n\n\n        #Search the Treeview Container\n        self.db_search_container = tk.Frame(tree_container)\n        self.db_search_container.pack(side=tk.BOTTOM, anchor=tk.N, padx=padx, pady=pady)\n\n\n        #BookID Search DB\n        db_search_label_bookID = tk.Label(self.db_search_container, text='ID: ', bg=bg)\n        db_search_label_bookID.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self._detached = set()\n        self.db_search_bookID_var = tk.StringVar()\n        self.db_search_bookID_var.trace(\"w\", self._columns_searcher_bookID_BD)\n\n        self.db_search_bookID_entry = ttk.Entry(self.db_search_container, textvariable=self.db_search_bookID_var)\n        self.db_search_bookID_entry.pack(side=tk.LEFT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Title Search DB\n        db_search_label_title = tk.Label(self.db_search_container, text='Title: ', bg=bg)\n        db_search_label_title.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self._detached = set()\n        self.db_search_title_var = tk.StringVar()\n        self.db_search_title_var.trace(\"w\", self._columns_searcher_title_BD)\n\n        self.db_search_title_entry = ttk.Entry(self.db_search_container, textvariable=self.db_search_title_var)\n        self.db_search_title_entry.pack(side=tk.LEFT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Author Search DB\n        db_search_label_author = tk.Label(self.db_search_container, text='Author: ', bg=bg)\n        db_search_label_author.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self._detached = set()\n        self.db_search_author_var = tk.StringVar()\n        self.db_search_author_var.trace(\"w\", self._columns_searcher_author_BD)\n\n        self.db_search_author_entry = ttk.Entry(self.db_search_container, textvariable=self.db_search_author_var)\n        self.db_search_author_entry.pack(side=tk.LEFT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Genre Search DB\n        db_search_label_genre = tk.Label(self.db_search_container, text='Genre: ', bg=bg)\n        db_search_label_genre.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self._detached = set()\n        self.db_search_genre_var = tk.StringVar()\n        self.db_search_genre_var.set(\"-EMPTY-\")\n        self.db_search_genre_var.trace(\"w\", self._columns_searcher_genre_BD)\n\n\n        self.db_search_genre_menu = ttk.OptionMenu(self.db_search_container, self.db_search_genre_var, genre_choice_list[0], *genre_choice_list)\n        self.db_search_genre_menu.pack(side=tk.LEFT, anchor=tk.E, padx=padx, pady=pady)\n\n\n\n        #Location Search DB\n        db_search_label_location = tk.Label(self.db_search_container, text='Location: ', bg=bg)\n        db_search_label_location.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self._detached = set()\n        self.db_search_location_var = tk.StringVar()\n        self.db_search_location_var.set(\"-EMPTY-\")\n        self.db_search_location_var.trace(\"w\", self._columns_searcher_location_BD)\n\n\n        self.db_search_location_menu = ttk.OptionMenu(self.db_search_container, self.db_search_location_var, location_choice_list[0], *location_choice_list)\n        self.db_search_location_menu.pack(side=tk.LEFT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Issued Search DB\n        db_search_label_issued = tk.Label(self.db_search_container, text='Issued(1/0): ', bg=bg)\n        db_search_label_issued.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self._detached = set()\n        self.db_search_issued_var = tk.StringVar()\n        self.db_search_issued_var.set(\"-EMPTY-\")\n        self.db_search_issued_var.trace(\"w\", self._columns_searcher_issued_BD)\n\n        self.db_search_issued_menu = ttk.OptionMenu(self.db_search_container, self.db_search_issued_var, issued_choice_list[0], *issued_choice_list)\n        self.db_search_issued_menu.pack(side=tk.LEFT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        for self.col in self.columns:\n                self.tree.heading(self.col, text=self.col,\n                                      command=lambda c=self.col: self.sort_upon_press(c))\n\n\n        #Issue/Return Books UI\n        filter_container = tk.Frame(book_database_page, bg=bg)\n        filter_container.pack(side=tk.LEFT, anchor=tk.N, padx=padx, pady=pady)\n\n        filter_header = tk.Label(filter_container, text='Issue Book', font='System 18', bg=bg)\n        filter_header.pack(anchor=tk.W, padx=padx, pady=pady)\n\n        #BookID Entry Field\n        self.search_container_bookID = tk.Frame(filter_container, bg=bg)\n        self.search_container_bookID.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        bookID_label = tk.Label(self.search_container_bookID, text='ID: ', bg=bg)\n        bookID_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.bookID_reg = root.register(self.bookID_validate)\n        self.bookID_var = tk.StringVar()\n\n        self.bookID_entry = ttk.Entry(self.search_container_bookID)\n        self.bookID_entry.config(textvariable=self.bookID_var, validate=\"key\",\n                            validatecommand=(self.bookID_reg, \"%P\"))\n        self.bookID_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        # Filler frame for the autocomplete function\n        self.search_container_canvas = tk.Canvas(filter_container, height=50, width=50, bg=bg)\n        self.search_container_canvas.pack(fill=tk.X, expand=True)\n\n        self.search_container_autocomplete = tk.Frame(self.search_container_canvas, bg=bg)\n        self.search_container_autocomplete.pack(anchor=tk.W, fill=tk.X, side=tk.TOP)\n\n\n        #Title Entry Field\n        self.search_container_title = tk.Frame(filter_container, bg=bg)\n        self.search_container_title.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        title_label = tk.Label(self.search_container_title, text='Title: ', bg=bg)\n        title_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.title_var = tk.StringVar()\n\n        self.title_entry = ttk.Entry(self.search_container_title, textvariable=self.title_var, state=tk.DISABLED)\n        self.title_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        #Author Entry Field\n        self.search_container_author = tk.Frame(filter_container, bg=bg)\n        self.search_container_author.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        author_label = tk.Label(self.search_container_author, text='Author: ', bg=bg)\n        author_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.author_var = tk.StringVar()\n\n        self.author_entry = ttk.Entry(self.search_container_author, textvariable=self.author_var, state=tk.DISABLED)\n        self.author_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Book recipient frame\n        recipient_container = tk.Frame(filter_container, bg=bg)\n        recipient_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        recipient_label = tk.Label(recipient_container, text='Recipient Email: ', bg=bg)\n        recipient_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.recipient_var = tk.StringVar()\n\n        recipient_entry = ttk.Entry(recipient_container, textvariable=self.recipient_var)\n        recipient_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Date entry frame\n        date_container = tk.Frame(filter_container, bg=bg)\n        date_container.pack(anchor=tk.W, fill=tk.X, expand=True)\n\n        recipient_label = tk.Label(date_container, text='Date of Issuing: ', bg=bg)\n        recipient_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.date_entry = DateEntry(date_container, width=12, background='darkblue',\n                    foreground='white', borderwidth=2, mindate=datetime.now(), maxdate=datetime.now(), locale='en_UK')\n        self.date_entry.pack(padx=padx, pady=pady)\n\n\n\n        #Return date frame\n        return_date_container = tk.Frame(filter_container, bg=bg)\n        return_date_container.pack(anchor=tk.W, fill=tk.X, expand=True)\n\n        return_date_label = tk.Label(return_date_container, text='Last Valid Return Date: ', bg=bg)\n        return_date_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        return_date_calc = str(self.date_entry.get_date() + timedelta(days=14))\n        return_date_value = str(datetime.strptime(return_date_calc, \"%Y-%m-%d\").strftime('%Y-%m-%d'))\n\n        self.return_date_var = tk.StringVar()\n        self.return_date_var.set(return_date_value)\n\n        return_date_entry = ttk.Entry(return_date_container, state=tk.DISABLED, textvariable=self.return_date_var)\n        return_date_entry.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n\n        #Issue Book Button Frame\n        issue_book_container = tk.Frame(filter_container, bg=bg)\n        issue_book_container.pack(anchor=tk.W, fill=tk.X, expand=True)\n\n\n        issue_book_btn = ttk.Button(issue_book_container)\n        issue_book_btn.config(text='    Issue Book    ', command=self.issue_book)\n        issue_book_btn.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        # Gather an updated list of books to be displayed correctly on the autocomplete box.\n\n\n        autocomplete_issue_bookID = AutoCompleteEntryBD_IssueBookID(self.search_container_autocomplete, self.title_entry, self.title_var, self.author_entry, self.author_var, self.bookID_var, self.bookID_entry, self.search_container_canvas)\n\n\n\n\n\n\n        ### Book Return ('ret' following the variable name is short for 'return' to differentiate between the variables above and below)\n        #Return Books UI\n        ret_filter_container = tk.Frame(book_database_page, bg=bg)\n        ret_filter_container.pack(side=tk.LEFT, anchor=tk.N, padx=padx, pady=pady)\n\n        ret_filter_header = tk.Label(ret_filter_container, text='Return Book', font='System 18', bg=bg)\n        ret_filter_header.pack(anchor=tk.W, padx=padx, pady=pady)\n\n        #BookID Entry Field\n        self.ret_search_container_bookID = tk.Frame(ret_filter_container, bg=bg)\n        self.ret_search_container_bookID.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        ret_bookID_label = tk.Label(self.ret_search_container_bookID, text='ID: ', bg=bg)\n        ret_bookID_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.ret_bookID_reg = root.register(self.ret_bookID_validate)\n        self.ret_bookID_var = tk.StringVar()\n\n        self.ret_bookID_entry = ttk.Entry(self.ret_search_container_bookID)\n        self.ret_bookID_entry.config(textvariable=self.ret_bookID_var, validate=\"key\",\n                            validatecommand=(self.ret_bookID_reg, \"%P\"))\n        self.ret_bookID_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Filler frame for the autocomplete function\n        self.ret_search_container_canvas = tk.Canvas(ret_filter_container, height=50, width=50, bg=bg)\n        self.ret_search_container_canvas.pack(fill=tk.X, expand=True)\n\n        self.ret_search_container_autocomplete = tk.Frame(self.ret_search_container_canvas, bg=bg)\n        self.ret_search_container_autocomplete.pack(anchor=tk.W, fill=tk.X, side=tk.TOP)\n\n\n        #Title Entry Field\n        self.ret_search_container_title = tk.Frame(ret_filter_container, bg=bg)\n        self.ret_search_container_title.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        ret_title_label = tk.Label(self.ret_search_container_title, text='Title: ', bg=bg)\n        ret_title_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.ret_title_var = tk.StringVar()\n\n        self.ret_title_entry = ttk.Entry(self.ret_search_container_title, textvariable=self.ret_title_var, state=tk.DISABLED)\n        self.ret_title_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        #Author Entry Field\n        self.ret_search_container_author = tk.Frame(ret_filter_container, bg=bg)\n        self.ret_search_container_author.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        ret_author_label = tk.Label(self.ret_search_container_author, text='Author: ', bg=bg)\n        ret_author_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.ret_author_var = tk.StringVar()\n\n        self.ret_author_entry = ttk.Entry(self.ret_search_container_author, textvariable=self.ret_author_var, state=tk.DISABLED)\n        self.ret_author_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Book recipient frame\n        ret_recipient_container = tk.Frame(ret_filter_container, bg=bg)\n        ret_recipient_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        ret_recipient_label = tk.Label(ret_recipient_container, text='Return Email: ', bg=bg)\n        ret_recipient_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.return_email_var = tk.StringVar()\n\n        ret_recipient_entry = ttk.Entry(ret_recipient_container, textvariable=self.return_email_var)\n        ret_recipient_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Date entry frame\n        ret_date_container = tk.Frame(ret_filter_container, bg=bg)\n        ret_date_container.pack(anchor=tk.W, fill=tk.X, expand=True)\n\n        ret_recipient_label = tk.Label(ret_date_container, text='Date of Return: ', bg=bg)\n        ret_recipient_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n\n        self.ret_date_entry = DateEntry(ret_date_container, width=12, background='darkblue',\n                    foreground='white', borderwidth=2, locale='en_UK')\n        self.ret_date_entry.pack(padx=padx, pady=pady)\n\n\n\n        #Return Book Button Frame\n        return_book_container = tk.Frame(ret_filter_container, bg=bg)\n        return_book_container.pack(anchor=tk.W, fill=tk.X, expand=True)\n\n\n        return_book_btn = ttk.Button(return_book_container)\n        return_book_btn.config(text='    Return Book    ', command=self.return_book)\n        return_book_btn.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n\n        autocomplete_return_bookID = AutoCompleteEntryBD_ReturnBookID(self.ret_search_container_autocomplete, self.ret_title_entry, self.ret_title_var, self.ret_author_entry, self.ret_author_var, self.ret_bookID_var, self.ret_bookID_entry, self.ret_date_entry, self.ret_search_container_canvas)\n\n\n\n\n\n        #Remove Books UI\n        remove_book_container = tk.Frame(book_database_page, bg=bg)\n        remove_book_container.pack(side=tk.RIGHT, anchor=tk.N, padx=padx, pady=pady)\n\n        remove_book_header = tk.Label(remove_book_container, text='Remove Book From System', font='System 18', bg=bg)\n        remove_book_header.pack(anchor=tk.W, padx=padx, pady=pady)\n\n        #BookID Entry Field\n        self.remove_container_bookID = tk.Frame(remove_book_container, bg=bg)\n        self.remove_container_bookID.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        remove_bookID_label = tk.Label(self.remove_container_bookID, text='ID: ', bg=bg)\n        remove_bookID_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.remove_bookID_reg = root.register(self.remove_bookID_validate)\n        self.remove_bookID_var = tk.StringVar()\n\n        self.remove_bookID_entry = ttk.Entry(self.remove_container_bookID)\n        self.remove_bookID_entry.config(textvariable=self.remove_bookID_var, validate=\"key\",\n                            validatecommand=(self.remove_bookID_reg, \"%P\"))\n        self.remove_bookID_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        #Filler frame for the autocomplete function\n        self.remove_container_canvas = tk.Canvas(remove_book_container, height=50, width=50, bg=bg)\n        self.remove_container_canvas.pack(fill=tk.X, expand=True)\n\n        self.remove_container_autocomplete = tk.Frame(self.remove_container_canvas, bg=bg)\n        self.remove_container_autocomplete.pack(anchor=tk.W, fill=tk.X, side=tk.TOP)\n\n\n        #Title Entry Field\n        self.remove_container_title = tk.Frame(remove_book_container, bg=bg)\n        self.remove_container_title.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        remove_title_label = tk.Label(self.remove_container_title, text='Title: ', bg=bg)\n        remove_title_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.remove_title_var = tk.StringVar()\n\n        self.remove_title_entry = ttk.Entry(self.remove_container_title, textvariable=self.remove_title_var, state=tk.DISABLED)\n        self.remove_title_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Author Entry Field\n        self.remove_container_author = tk.Frame(remove_book_container, bg=bg)\n        self.remove_container_author.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        remove_author_label = tk.Label(self.remove_container_author, text='Author: ', bg=bg)\n        remove_author_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.remove_author_var = tk.StringVar()\n\n        self.remove_author_entry = ttk.Entry(self.remove_container_author, textvariable=self.remove_author_var, state=tk.DISABLED)\n        self.remove_author_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Genre Entry Field\n        self.remove_container_genre = tk.Frame(remove_book_container, bg=bg)\n        self.remove_container_genre.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        remove_genre_label = tk.Label(self.remove_container_genre, text='Genre: ', bg=bg)\n        remove_genre_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.remove_genre_var = tk.StringVar()\n        self.remove_genre_var.set(\"-EMPTY-\")\n\n        self.remove_genre_menu = ttk.OptionMenu(self.remove_container_genre, self.remove_genre_var,genre_choice_list[0], *genre_choice_list)\n        self.remove_genre_menu.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Remove Book Button Frame\n        remove_book_container = tk.Frame(remove_book_container, bg=bg)\n        remove_book_container.pack(anchor=tk.W, fill=tk.X, expand=True)\n\n\n        remove_book_btn = ttk.Button(remove_book_container)\n        remove_book_btn.config(text='    Remove Book    ', command=self.remove_book)\n        remove_book_btn.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        autocomplete_remove_bookID = AutoCompleteEntryBD_RemoveBookID(self.remove_container_autocomplete, self.remove_title_entry, self.remove_title_var,self.remove_author_entry, self.remove_author_var, self.remove_bookID_var, self.remove_bookID_entry, self.remove_genre_var, self.remove_genre_menu, self.remove_container_canvas)\n\n\n        #Add Books UI\n        add_book_container = tk.Frame(book_database_page, bg=bg)\n        add_book_container.pack(side=tk.RIGHT, anchor=tk.N, padx=padx, pady=pady)\n\n        add_book_header = tk.Label(add_book_container, text='Add Book Into System', font='System 18', bg=bg)\n        add_book_header.pack(anchor=tk.W, padx=padx, pady=pady)\n\n        #BookID Entry Field\n        self.add_container_bookID = tk.Frame(add_book_container, bg=bg)\n        self.add_container_bookID.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        add_bookID_label = tk.Label(self.add_container_bookID, text='ID: ', bg=bg)\n        add_bookID_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.add_bookID_var = tk.StringVar()\n\n        select_highest_val = c.execute('SELECT MAX(bookID) + 1 FROM Books').fetchall()\n        highest_val = [x[0] for x in select_highest_val][0]\n\n        self.add_bookID_var.set(highest_val)\n\n        self.add_bookID_entry = ttk.Entry(self.add_container_bookID, textvariable=self.add_bookID_var, state=tk.DISABLED)\n        self.add_bookID_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Title Entry Field\n        self.add_container_title = tk.Frame(add_book_container, bg=bg)\n        self.add_container_title.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        add_title_label = tk.Label(self.add_container_title, text='Title: ', bg=bg)\n        add_title_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.add_title_var = tk.StringVar()\n\n        self.add_title_entry = ttk.Entry(self.add_container_title, textvariable=self.add_title_var)\n        self.add_title_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Author Entry Field\n        self.add_container_author = tk.Frame(add_book_container, bg=bg)\n        self.add_container_author.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        add_author_label = tk.Label(self.add_container_author, text='Author: ', bg=bg)\n        add_author_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.add_author_var = tk.StringVar()\n\n        self.add_author_entry = ttk.Entry(self.add_container_author, textvariable=self.add_author_var)\n        self.add_author_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Genre Entry Field\n        self.add_container_genre = tk.Frame(add_book_container, bg=bg)\n        self.add_container_genre.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        add_genre_label = tk.Label(self.add_container_genre, text='Genre: ', bg=bg)\n        add_genre_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.add_genre_var = tk.StringVar()\n        self.add_genre_var.set(\"-EMPTY-\")\n\n        self.add_genre_menu = ttk.OptionMenu(self.add_container_genre, self.add_genre_var,genre_choice_list[0], *genre_choice_list)\n        self.add_genre_menu.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        #Add Book Button Frame\n        add_book_container_button = tk.Frame(add_book_container, bg=bg)\n        add_book_container_button.pack(anchor=tk.W, fill=tk.X, expand=True)\n\n\n        add_book_btn = ttk.Button(add_book_container_button)\n        add_book_btn.config(text='    Add Book    ', command=self.add_book)\n        add_book_btn.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n\n        #Add New Genre Entry Field\n        self.container_newgenre = tk.Frame(add_book_container, bg=bg)\n        self.container_newgenre.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n\n        newgenre_main_label = tk.Label(self.container_newgenre, text='Add Genre Into the System', font='System 18', bg=bg)\n        newgenre_main_label.pack(anchor=tk.W, padx=padx, pady=pady)\n\n\n        newgenre_label = tk.Label(self.container_newgenre, text='Genre Name: ', bg=bg)\n        newgenre_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.newgenre_var = tk.StringVar()\n\n        self.newgenre_entry = ttk.Entry(self.container_newgenre, textvariable=self.newgenre_var)\n        self.newgenre_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        #Add New Genre Button Frame\n        container_newgenre_button = tk.Frame(add_book_container, bg=bg)\n        container_newgenre_button.pack(anchor=tk.W, fill=tk.X, expand=True)\n\n\n        add_newgenre_btn = ttk.Button(container_newgenre_button)\n        add_newgenre_btn.config(text='    Add New Genre    ', command=self.add_newgenre)\n        add_newgenre_btn.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        remove_newgenre_btn = ttk.Button(container_newgenre_button)\n        remove_newgenre_btn.config(text='    Remove Genre    ', command=self.remove_newgenre)\n        remove_newgenre_btn.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n    def add_newgenre(self):\n        #Requires input validation\n\n        #Fetch entry field values\n        newgenre_var = self.newgenre_var.get()\n        \n        #Check if the entered genre already exists\n        c.execute(\"SELECT genre FROM Genres\")\n        genres_list_fetch = c.fetchall()\n        genre_choice_list = [x[0] for x in genres_list_fetch]\n\n        if newgenre_var in genre_choice_list:\n            ms.showerror('Error','This genre is already in the system.')\n        else:\n            #Add new genre to db\n            insert_newgenre = 'INSERT INTO Genres(genre) VALUES(?)'\n            c.execute(insert_newgenre,[(newgenre_var)])\n            conn.commit()\n\n            #Update genre_choice_list and the related OptionMenus\n            #List of genres\n            c.execute(\"SELECT genre FROM Genres\")\n            genres_list_fetch = c.fetchall()\n            genre_choice_list = [x[0] for x in genres_list_fetch]\n\n            #Update Add Book OptionMenu in BookDB Page\n            add_menu = self.add_genre_menu[\"menu\"]\n            add_menu.delete(0, tk.END)\n            for string in genre_choice_list:\n                add_menu.add_command(label=string,\n                                 command=lambda value=string: self.add_genre_var.set(value))\n\n            #Update Remove Book OptionMenu in BookDB Page\n            remove_menu = self.remove_genre_menu[\"menu\"]\n            remove_menu.delete(0, tk.END)\n            for string in genre_choice_list:\n                remove_menu.add_command(label=string,\n                                 command=lambda value=string: self.add_genre_var.set(value))\n\n            #Update genre search in bookDB page\n            search_genre_menu = self.db_search_genre_menu[\"menu\"]\n            search_genre_menu.delete(0, tk.END)\n            for string in genre_choice_list:\n                search_genre_menu.add_command(label=string,\n                                 command=lambda value=string: self.db_search_genre_var.set(value))\n\n            ms.showinfo('Success', 'Genre added to the database successfully')\n\n\n\n    def remove_newgenre(self):\n        #Requires input validation\n\n        #Fetch entry field values\n        newgenre_var = self.newgenre_var.get()\n        \n        #Check if the entered genre already exists\n        c.execute(\"SELECT genre FROM Genres\")\n        genres_list_fetch = c.fetchall()\n        genre_choice_list = [x[0] for x in genres_list_fetch]\n\n        if newgenre_var not in genre_choice_list:\n            ms.showerror('Error',\"This genre isn't in the system.\")\n        elif newgenre_var == '-EMPTY-':\n            ms.showerror(\"Error\",\"You cannot remove this genre.\")\n        else:\n            #Find if the genre is being used by any books\n            used_genre_fetch = c.execute('SELECT genre FROM Books WHERE genre=?',(newgenre_var,)).fetchall()\n            used_genre = [x[0] for x in used_genre_fetch]\n\n            if len(used_genre) > 0:\n                ms.showerror('Error','Genre is currently in use by other books')\n            else:\n                #Remove new genre from db\n                remove_genre = c.execute('DELETE FROM Genres WHERE genre=?',(newgenre_var,))\n                conn.commit()\n\n                #Update genre_choice_list and the related OptionMenus\n                #List of genres\n                c.execute(\"SELECT genre FROM Genres\")\n                genres_list_fetch = c.fetchall()\n                genre_choice_list = [x[0] for x in genres_list_fetch]\n\n                add_menu = self.add_genre_menu[\"menu\"]\n                add_menu.delete(0, tk.END)\n                for string in genre_choice_list:\n                    add_menu.add_command(label=string,\n                                            command=lambda value=string: self.remove_genre_var.set(value))\n\n                #Update Remove Book OptionMenu in BookDB Page\n                remove_menu = self.remove_genre_menu[\"menu\"]\n                remove_menu.delete(0, tk.END)\n                for string in genre_choice_list:\n                    remove_menu.add_command(label=string,\n                                     command=lambda value=string: self.remove_genre_var.set(value))\n\n                #Update genre search in bookDB page\n                search_genre_menu = self.db_search_genre_menu[\"menu\"]\n                search_genre_menu.delete(0, tk.END)\n                for string in genre_choice_list:\n                    search_genre_menu.add_command(label=string,\n                                     command=lambda value=string: self.db_search_genre_var.set(value))\n\n                ms.showinfo('Success', 'Genre removed from the database successfully')\n\n\n\n    def add_book(self):\n\n        #Fetch entry field values\n        add_bookID_var = self.add_bookID_var.get()\n        add_title_var = self.add_title_var.get()\n        add_author_var =  self.add_author_var.get()\n        add_genre_var = self.add_genre_var.get()\n\n        #The location of the book within the physical library, will be based on the first letter of its Title.\n        #The shelves will be split into 27 different locations (alphabet + an '*' to signify any book whose title doesn't start with an alphabetical character.)\n        #Example, Title= 1 step closer. Location=*\n        #Example 2, Title=Drowning, Location=D\n\n        for letter in string.ascii_uppercase:\n            if letter == add_title_var[0]:\n                location=letter\n            elif add_title_var[0] not in string.ascii_uppercase:\n                location='*'\n\n        #Insert fetched values into database\n        insert_book_info = 'INSERT INTO Books(bookID, title, author, genre, issued, location) VALUES(?,?,?,?,0,?)'\n        c.execute(insert_book_info,[(add_bookID_var), (add_title_var), (add_author_var), (add_genre_var),(location)])\n        conn.commit()\n\n        #Increase the displayed bookID on the Add Book section\n        select_highest_val = c.execute('SELECT MAX(bookID) + 1 FROM Books').fetchall()\n        highest_val = [x[0] for x in select_highest_val][0]\n\n        self.add_bookID_var.set(highest_val)\n\n        #Set entryfields to empty after addition\n        self.add_title_var.set('')\n        self.add_author_var.set('')\n\n\n        #Update TreeView\n        #Book IDs\n        c.execute(\"SELECT bookID FROM Books\")\n        bookIDs_fetch = c.fetchall()\n        bookID_list = [x[0] for x in bookIDs_fetch]\n\n        #Titles\n        c.execute(\"SELECT title FROM Books\")\n        title_fetch = c.fetchall()\n        title_list = [x[0] for x in title_fetch]\n\n        #Authors\n        c.execute(\"SELECT author FROM Books\")\n        author_fetch = c.fetchall()\n        author_list = [x[0] for x in author_fetch]\n\n        #Genres\n        c.execute(\"SELECT genre FROM Books\")\n        genre_fetch = c.fetchall()\n        genre_list = [x[0] for x in genre_fetch]\n\n        #location\n        c.execute(\"SELECT location FROM Books\")\n        location_fetch = c.fetchall()\n        location_list = [x[0] for x in location_fetch]\n\n        #Issued/Not Issued\n        c.execute(\"SELECT issued FROM Books\")\n        issued_fetch = c.fetchall()\n        issued_list = [x[0] for x in issued_fetch]\n\n        for k in self.tree.get_children():\n            self.tree.delete(k)\n\n        for i in range(len(bookID_list)):\n            #Issue Date\n            c.execute(\"SELECT date_issued FROM MyBooks WHERE my_booksID=(SELECT my_booksID WHERE bookID=?)\",(bookID_list[i],))\n            date_issued_fetch = c.fetchall()\n            date_issued_list = [x[0] for x in date_issued_fetch]\n\n            #Return Date\n            c.execute(\"SELECT return_date FROM MyBooks WHERE my_booksID=(SELECT my_booksID WHERE bookID=?)\",(bookID_list[i],))\n            return_date_fetch = c.fetchall()\n            return_date_list = [x[0] for x in return_date_fetch]\n\n            #creates an entry in the tree for each element of the list\n            #then stores the id of the tree in the self.ids list\n            if len(date_issued_list)==0 or len(return_date_list)==0:\n                self.tree_ids.append(self.tree.insert(\"\", \"end\", values=(bookID_list[i], title_list[i], author_list[i], genre_list[i], location_list[i], issued_list[i], 'N/A', 'N/A')))\n            else:\n                self.tree_ids.append(self.tree.insert(\"\", \"end\", values=(bookID_list[i], title_list[i], author_list[i], genre_list[i], location_list[i], issued_list[i], date_issued_list[0], return_date_list[0])))\n        self.tree.pack()\n\n        for self.col in self.columns:\n                self.tree.heading(self.col, text=self.col,\n                                      command=lambda c=self.col: self.sort_upon_press(c))\n\n        ms.showinfo('Success', 'Book added to the database successfully')\n\n        \n\n\n\n    def remove_book(self):\n        \n        #Fetch entry field values\n        remove_bookID_var = self.remove_bookID_var.get()\n\n        remove_bookID_search = c.execute('DELETE FROM Books WHERE bookID=?',(remove_bookID_var,))\n        conn.commit()\n\n        #Check if anyone owns said book and remove it from their My Books table\n        check_book_owned = c.execute('SELECT my_booksID FROM MyBooks WHERE bookID=?',(remove_bookID_var,)).fetchall()\n        book_owner = [x[0] for x in check_book_owned]\n\n        if len(book_owner)==1:\n            remove_bookID_search = c.execute('DELETE FROM MyBooks WHERE bookID=?',(remove_bookID_var,))\n            conn.commit()\n\n        #Set entryfields to empty after removal\n        self.remove_bookID_var.set('')\n        self.remove_title_var.set('')\n        self.remove_author_var.set('')\n\n        #Update TreeView\n        #Book IDs\n        c.execute(\"SELECT bookID FROM Books\")\n        bookIDs_fetch = c.fetchall()\n        bookID_list = [x[0] for x in bookIDs_fetch]\n\n        #Titles\n        c.execute(\"SELECT title FROM Books\")\n        title_fetch = c.fetchall()\n        title_list = [x[0] for x in title_fetch]\n\n        #Authors\n        c.execute(\"SELECT author FROM Books\")\n        author_fetch = c.fetchall()\n        author_list = [x[0] for x in author_fetch]\n\n        #Genres\n        c.execute(\"SELECT genre FROM Books\")\n        genre_fetch = c.fetchall()\n        genre_list = [x[0] for x in genre_fetch]\n\n        #location\n        c.execute(\"SELECT location FROM Books\")\n        location_fetch = c.fetchall()\n        location_list = [x[0] for x in location_fetch]\n\n        #Issued/Not Issued\n        c.execute(\"SELECT issued FROM Books\")\n        issued_fetch = c.fetchall()\n        issued_list = [x[0] for x in issued_fetch]\n\n        for k in self.tree.get_children():\n            self.tree.delete(k)\n\n        for i in range(len(bookID_list)):\n            #Issue Date\n            c.execute(\"SELECT date_issued FROM MyBooks WHERE my_booksID=(SELECT my_booksID WHERE bookID=?)\",(bookID_list[i],))\n            date_issued_fetch = c.fetchall()\n            date_issued_list = [x[0] for x in date_issued_fetch]\n\n            #Return Date\n            c.execute(\"SELECT return_date FROM MyBooks WHERE my_booksID=(SELECT my_booksID WHERE bookID=?)\",(bookID_list[i],))\n            return_date_fetch = c.fetchall()\n            return_date_list = [x[0] for x in return_date_fetch]\n\n            #creates an entry in the tree for each element of the list\n            #then stores the id of the tree in the self.ids list\n            if len(date_issued_list)==0 or len(return_date_list)==0:\n                self.tree_ids.append(self.tree.insert(\"\", \"end\", values=(bookID_list[i], title_list[i], author_list[i], genre_list[i], location_list[i], issued_list[i], 'N/A', 'N/A')))\n            else:\n                self.tree_ids.append(self.tree.insert(\"\", \"end\", values=(bookID_list[i], title_list[i], author_list[i], genre_list[i], location_list[i], issued_list[i], date_issued_list[0], return_date_list[0])))\n        self.tree.pack()\n\n        for self.col in self.columns:\n                self.tree.heading(self.col, text=self.col,\n                                      command=lambda c=self.col: self.sort_upon_press(c))\n\n        ms.showinfo('Success', 'Book removed from the database successfully')\n\n\n\n\n\n    def issue_book(self):\n        #Send entered information to the database.\n\n        #May need try/except block here\n        bookID_var = self.bookID_var.get()\n        title_var = self.title_var.get()\n        author_var = self.author_var.get()\n        recipient_email = self.recipient_var.get()\n        date_issued = self.date_entry.get_date()\n\n        date_issued_string = str(date_issued.strftime('%d-%m-%Y'))\n\n        if str(date_issued_string) == str(datetime.today().strftime('%d-%m-%Y')):\n            date_return = self.return_date_var.get()\n\n            book_id_search = c.execute('SELECT bookID FROM Books WHERE title=? AND author=? ',(title_var, author_var)).fetchall()\n            book_id = [x[0] for x in book_id_search][0]\n\n            # Send info to db\n            account_info_fetch = c.execute('SELECT * FROM Accounts WHERE email_address=?',(recipient_email,)).fetchall()\n            account_mybooks_check = [x[5] for x in account_info_fetch][0]\n\n            #Check if book is already issued out\n            book_already_issued_fetch = c.execute('SELECT issued FROM Books WHERE bookID=?',(bookID_var,)).fetchall()\n            book_already_issued = [x[0] for x in book_already_issued_fetch][0]\n\n            if book_already_issued == 0:\n                insert_my_bookID = 'INSERT INTO MyBooks(my_booksID,bookID) VALUES(?,?)'\n                c.execute(insert_my_bookID,[(account_mybooks_check),(book_id)])\n                conn.commit()\n\n                update_issued_val = c.execute('UPDATE Books SET issued=1 WHERE bookID=?',(book_id,))\n                conn.commit()\n\n                update_date_issued_val = c.execute(\"\"\"UPDATE MyBooks\n                    SET date_issued=?\n                    WHERE my_booksID = (SELECT my_booksID FROM Accounts WHERE email_address=?)\"\"\",(date_issued, recipient_email))\n                conn.commit()\n\n                update_return_date_val = c.execute(\"\"\"UPDATE MyBooks\n                    SET return_date=?\n                    WHERE my_booksID = (SELECT my_booksID FROM Accounts WHERE email_address=?)\"\"\",(date_return, recipient_email))\n                conn.commit()\n            else:\n                ms.showerror('Error','This book has already been issued.')\n\n            #Set entryfields to empty after issue\n            self.bookID_var.set('')\n            self.title_var.set('')\n            self.author_var.set('')\n            self.recipient_var.set('')\n\n            #update treeview BookDatabase when the book is issued\n            #gather db info to check if book has been issued, so that we only show the books that have NOT been issued.\n\n            #Book IDs\n            c.execute(\"SELECT bookID FROM Books\")\n            bookIDs_fetch = c.fetchall()\n            bookID_list = [x[0] for x in bookIDs_fetch]\n\n            #Titles\n            c.execute(\"SELECT title FROM Books\")\n            title_fetch = c.fetchall()\n            title_list = [x[0] for x in title_fetch]\n\n            #Authors\n            c.execute(\"SELECT author FROM Books\")\n            author_fetch = c.fetchall()\n            author_list = [x[0] for x in author_fetch]\n\n            #Genres\n            c.execute(\"SELECT genre FROM Books\")\n            genre_fetch = c.fetchall()\n            genre_list = [x[0] for x in genre_fetch]\n\n            #location\n            c.execute(\"SELECT location FROM Books\")\n            location_fetch = c.fetchall()\n            location_list = [x[0] for x in location_fetch]\n\n            #Issued/Not Issued\n            c.execute(\"SELECT issued FROM Books\")\n            issued_fetch = c.fetchall()\n            issued_list = [x[0] for x in issued_fetch]\n\n            for k in self.tree.get_children():\n                self.tree.delete(k)\n\n            for i in range(len(bookID_list)):\n                #Issue Date\n                c.execute(\"SELECT date_issued FROM MyBooks WHERE my_booksID=(SELECT my_booksID WHERE bookID=?)\",(bookID_list[i],))\n                date_issued_fetch = c.fetchall()\n                date_issued_list = [x[0] for x in date_issued_fetch]\n\n                #Return Date\n                c.execute(\"SELECT return_date FROM MyBooks WHERE my_booksID=(SELECT my_booksID WHERE bookID=?)\",(bookID_list[i],))\n                return_date_fetch = c.fetchall()\n                return_date_list = [x[0] for x in return_date_fetch]\n\n                #creates an entry in the tree for each element of the list\n                #then stores the id of the tree in the self.ids list\n                if len(date_issued_list)==0 or len(return_date_list)==0:\n                    self.tree_ids.append(self.tree.insert(\"\", \"end\", values=(bookID_list[i], title_list[i], author_list[i], genre_list[i], location_list[i], issued_list[i], 'N/A', 'N/A')))\n                else:\n                    self.tree_ids.append(self.tree.insert(\"\", \"end\", values=(bookID_list[i], title_list[i], author_list[i], genre_list[i], location_list[i], issued_list[i], date_issued_list[0], return_date_list[0])))\n            self.tree.pack()\n\n            for self.col in self.columns:\n                self.tree.heading(self.col, text=self.col,\n                                      command=lambda c=self.col: self.sort_upon_press(c))\n\n            ms.showinfo('Success', 'Book issued out successfully')\n        else:\n            ms.showerror('Error','Invalid DOI (Date of Issue)')\n\n\n\n    def return_book(self):\n        #Send entered information to the database.\n        #Retrieve all entryboxes variables\n\n        #May need try/except block here\n        title_var = self.ret_title_var.get()\n        author_var = self.ret_author_var.get()\n        return_email = self.return_email_var.get()\n        date_return = self.return_date_var.get()\n\n        book_id_search = c.execute('SELECT bookID FROM Books WHERE title=? AND author=? ',(title_var, author_var)).fetchall()\n        book_id = [x[0] for x in book_id_search][0]\n\n        # Send info to db\n        #could be shortened a bit.\n        account_info_fetch = c.execute('SELECT * FROM Accounts WHERE email_address=?',(return_email,)).fetchall()\n        account_mybooks_check = [x[4] for x in account_info_fetch][0]\n\n        #Remove my_booksID from the ownership of the user and onto the public library.\n\n        remove_my_booksID = 'DELETE FROM MyBooks WHERE bookID=?'\n        c.execute(remove_my_booksID,[(book_id)])\n        conn.commit()\n\n        update_issued_val = c.execute('UPDATE Books SET issued=0 WHERE bookID=?',(book_id,))\n        conn.commit()\n\n        #Set entryfields to empty after return\n        self.ret_bookID_var.set('')\n        self.ret_title_var.set('')\n        self.ret_author_var.set('')\n        self.return_email_var.set('')\n\n        #Update Treeview table in BookDatabase Page\n        #Maybe pack into a function?\n        #Book IDs\n        c.execute(\"SELECT bookID FROM Books\")\n        bookIDs_fetch = c.fetchall()\n        bookID_list = [x[0] for x in bookIDs_fetch]\n\n        #Titles\n        c.execute(\"SELECT title FROM Books\")\n        title_fetch = c.fetchall()\n        title_list = [x[0] for x in title_fetch]\n\n        #Authors\n        c.execute(\"SELECT author FROM Books\")\n        author_fetch = c.fetchall()\n        author_list = [x[0] for x in author_fetch]\n\n        #Genres\n        c.execute(\"SELECT genre FROM Books\")\n        genre_fetch = c.fetchall()\n        genre_list = [x[0] for x in genre_fetch]\n\n        #location\n        c.execute(\"SELECT location FROM Books\")\n        location_fetch = c.fetchall()\n        location_list = [x[0] for x in location_fetch]\n\n        #Issued/Not Issued\n        c.execute(\"SELECT issued FROM Books\")\n        issued_fetch = c.fetchall()\n        issued_list = [x[0] for x in issued_fetch]\n\n        for k in self.tree.get_children():\n            self.tree.delete(k)\n\n        for i in range(len(bookID_list)):\n            #Issue Date\n            c.execute(\"SELECT date_issued FROM MyBooks WHERE my_booksID=(SELECT my_booksID WHERE bookID=?)\",(bookID_list[i],))\n            date_issued_fetch = c.fetchall()\n            date_issued_list = [x[0] for x in date_issued_fetch]\n\n            #Return Date\n            c.execute(\"SELECT return_date FROM MyBooks WHERE my_booksID=(SELECT my_booksID WHERE bookID=?)\",(bookID_list[i],))\n            return_date_fetch = c.fetchall()\n            return_date_list = [x[0] for x in return_date_fetch]\n\n            #creates an entry in the tree for each element of the list\n            #then stores the id of the tree in the self.ids list\n            if len(date_issued_list)==0 or len(return_date_list)==0:\n                self.tree_ids.append(self.tree.insert(\"\", \"end\", values=(bookID_list[i], title_list[i], author_list[i], genre_list[i], location_list[i], issued_list[i], 'N/A', 'N/A')))\n            else:\n                self.tree_ids.append(self.tree.insert(\"\", \"end\", values=(bookID_list[i], title_list[i], author_list[i], genre_list[i], location_list[i], issued_list[i], date_issued_list[0], return_date_list[0])))\n        self.tree.pack()\n\n        for self.col in self.columns:\n                self.tree.heading(self.col, text=self.col,\n                                      command=lambda c=self.col: self.sort_upon_press(c))\n\n        ms.showinfo('Success', 'Book returned successfully')\n\n    def bookID_validate(self, bookID_input):\n        if bookID_input.isdigit():\n            return True\n        elif bookID_input is \"\":\n            return True\n        else:\n            return False\n\n    def ret_bookID_validate(self, ret_bookID_input):\n        if ret_bookID_input.isdigit():\n            return True\n        elif ret_bookID_input is \"\":\n            return True\n        else:\n            return False\n\n    def remove_bookID_validate(self, remove_bookID_input):\n        if remove_bookID_input.isdigit():\n            return True\n        elif remove_bookID_input is \"\":\n            return True\n        else:\n            return False\n\n\n\n    def _columns_searcher_bookID_BD(self, *args):\n        children = list(self._detached) + list(self.tree.get_children())\n        self._detached = set()\n        query_bookID = self.db_search_bookID_var.get()\n\n        self.search_bookID_tv_BD(children, query_bookID)\n\n    def _columns_searcher_title_BD(self, *args):\n        children = list(self._detached) + list(self.tree.get_children())\n        self._detached = set()\n        query_title = self.db_search_title_var.get()\n\n        self.search_title_tv_BD(children, query_title)\n\n    def _columns_searcher_author_BD(self, *args):\n        children = list(self._detached) + list(self.tree.get_children())\n        self._detached = set()\n        query_author = self.db_search_author_var.get()\n\n        self.search_author_tv_BD(children, query_author)\n\n    def _columns_searcher_genre_BD(self, *args):\n        children = list(self._detached) + list(self.tree.get_children())\n        self._detached = set()\n        query_genre = self.db_search_genre_var.get()\n\n        self.search_genre_tv_BD(children, query_genre)\n\n    def _columns_searcher_location_BD(self, *args):\n        children = list(self._detached) + list(self.tree.get_children())\n        self._detached = set()\n        query_location = self.db_search_location_var.get()\n\n        self.search_location_tv_BD(children, query_location)\n\n    def _columns_searcher_issued_BD(self, *args):\n        children = list(self._detached) + list(self.tree.get_children())\n        self._detached = set()\n        query_issued = self.db_search_issued_var.get()\n\n        self.search_issued_tv_BD(children, query_issued)\n\n    def search_bookID_tv_BD(self, children, query_bookID):\n        i_r = -1\n\n        for item_id in children:\n            bookID_text = str(self.tree.item(item_id)['values'][0])\n\n            if query_bookID in bookID_text:\n                i_r += 1\n                self.tree.reattach(item_id, '', i_r)\n\n            else:\n                self._detached.add(item_id)\n                self.tree.detach(item_id)\n\n    def search_title_tv_BD(self, children, query_title):\n        i_r = -1\n\n        for item_id in children:\n            title_text = self.tree.item(item_id)['values'][1]\n\n            if query_title in title_text:\n                i_r += 1\n                self.tree.reattach(item_id, '', i_r)\n\n            else:\n                self._detached.add(item_id)\n                self.tree.detach(item_id)\n\n    def search_author_tv_BD(self, children, query_author):\n        i_r = -1\n\n        for item_id in children:\n            author_text = self.tree.item(item_id)['values'][2]\n\n            if query_author in author_text:\n                i_r += 1\n                self.tree.reattach(item_id, '', i_r)\n\n            else:\n                self._detached.add(item_id)\n                self.tree.detach(item_id)\n\n    def search_genre_tv_BD(self, children, query_genre):\n        i_r = -1\n\n        for item_id in children:\n            genre_text = self.tree.item(item_id)['values'][3]\n\n            if query_genre in genre_text:\n                i_r += 1\n                self.tree.reattach(item_id, '', i_r)\n\n            elif query_genre == '-EMPTY-':\n                self.tree.reattach(item_id, '', i_r)\n\n            else:\n                self._detached.add(item_id)\n                self.tree.detach(item_id)\n\n    def search_location_tv_BD(self, children, query_location):\n        i_r = -1\n\n        for item_id in children:\n            location_text = self.tree.item(item_id)['values'][4]\n\n            if query_location in location_text:\n                i_r += 1\n                self.tree.reattach(item_id, '', i_r)\n\n            elif query_location == '-EMPTY-':\n                self.tree.reattach(item_id, '', i_r)\n\n            else:\n                self._detached.add(item_id)\n                self.tree.detach(item_id)\n\n    def search_issued_tv_BD(self, children, query_issued):\n        i_r = -1\n\n        for item_id in children:\n            issued_text = self.tree.item(item_id)['values'][5]\n            print(issued_text)\n\n            if query_issued in str(issued_text):\n                i_r += 1\n                self.tree.reattach(item_id, '', i_r)\n\n            elif query_issued == '-EMPTY-':\n                self.tree.reattach(item_id, '', i_r)\n\n            else:\n                self._detached.add(item_id)\n                self.tree.detach(item_id)\n\n    def sort_upon_press(self, c):\n        self.arr = [(self.tree.set(k, c), k) for k in self.tree.get_children('')]\n        self.n = len(self.arr)\n        self.quickSort(self.tree, c, self.arr, 0, self.n-1, False)\n\n    def partition(self, arr,low, high):\n        i = (low-1)\n        pivot = arr[high]\n     \n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i = i+1\n                arr[i], arr[j] = arr[j], arr[i]\n     \n        arr[i+1], arr[high] = arr[high], arr[i+1]\n        return (i+1)\n     \n     \n    def quickSort(self, tv, col, arr, low, high, reverse):\n        #Need to update arr if a new value is added to the treeview\n        if len(arr) == 1:\n            return arr\n        if low < high:\n            # pi is partitioning index, arr[p] is now\n            # at right place\n            pi = self.partition(arr, low, high)\n     \n            # Separately sort elements before\n            # partition and after partition\n            self.quickSort(tv, col, arr, low, pi-1, reverse=reverse)\n            self.quickSort(tv, col, arr, pi+1, high, reverse=reverse)\n\n        for index, (val, k) in enumerate(arr):\n            tv.move(k, '', index)\n\n        tv.heading(col, command=lambda: \\\n            self.quickSort(tv, col, arr, low, high, not reverse))\n        if reverse == True:\n            arr_reverse = arr[::-1]\n            for index, (val, k) in enumerate(arr_reverse):\n                tv.move(k, '', index)\n\n\n\nclass AutoCompleteEntryBD_ReturnBookID(ttk.Entry):\n    def __init__(self, ret_search_container_autocomplete, ret_title_entry, ret_title_var, ret_author_entry, ret_author_var, ret_bookID_var, ret_bookID_entry, ret_date_entry, ret_search_container_canvas, *args, **kwargs):\n\n        self.ret_search_container_autocomplete = ret_search_container_autocomplete\n        self.ret_bookID_entry = ret_bookID_entry\n        self.ret_title_entry = ret_title_entry\n        self.ret_author_entry = ret_author_entry\n        self.ret_date_entry = ret_date_entry\n        self.ret_search_container_canvas = ret_search_container_canvas\n\n        # Listbox length\n        if 'listboxLength' in kwargs:\n            self.listboxLength = kwargs['listboxLength']\n            del kwargs['listboxLength']\n        else:\n            self.listboxLength = 8\n\n\n        ttk.Entry.__init__(self, *args, **kwargs)\n        self.focus()\n\n        #Fetch database books that have been issued (issued=1)\n        #Titles\n        c.execute(\"SELECT bookID FROM Books WHERE issued=1\")\n        issued_bookIDs_fetch = c.fetchall()\n        issued_bookIDs_list = [x[0] for x in issued_bookIDs_fetch]\n\n        self.listb = issued_bookIDs_list\n\n        self.ret_bookID_var = ret_bookID_var\n        self.ret_title_var = ret_title_var\n        self.ret_author_var = ret_author_var\n\n        self.ret_bookID_entry = self[\"textvariable\"]\n        if self.ret_bookID_entry == '':\n            self.ret_bookID_entry = self[\"textvariable\"] = tk.StringVar()\n\n        self.ret_bookID_var.trace('w', self.changed)\n        self.bind(\"<Right>\", self.selection)\n        self.bind(\"<Up>\", self.up)\n        self.bind(\"<Down>\", self.down)\n        \n        self.lb_up = False\n\n    def changed(self, name, index, mode):\n        #Fetch database books that have been issued (issued=1)\n        #Titles\n        c.execute(\"SELECT bookID FROM Books WHERE issued=1\")\n        issued_bookIDs_fetch = c.fetchall()\n        issued_bookIDs = [x[0] for x in issued_bookIDs_fetch]\n\n        self.listb = issued_bookIDs\n\n        if self.ret_search_container_autocomplete.winfo_ismapped() == False:\n            self.ret_search_container_autocomplete.pack(anchor=tk.W, fill=tk.X, side=tk.TOP)\n\n\n        if self.ret_bookID_var.get() == '':\n            if self.lb_up:\n                self.lb.destroy()\n                self.lb_up = False\n        else:\n            words = self.comparison()\n            if words:            \n                if not self.lb_up:\n                    self.lb = tk.Listbox(self.ret_search_container_canvas, width=self[\"width\"], height=self.listboxLength)\n                    self.lb.bind(\"<Double-Button-1>\", self.selection)\n                    self.lb.bind(\"<Right>\", self.selection)\n                    self.lb.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n                    self.lb_up = True\n\n                self.lb.delete(0, tk.END)\n\n\n                for w in words:\n                    self.lb.insert(tk.END,w)\n            else:\n                if self.lb_up:\n                    self.lb.destroy()\n                    self.lb_up = False\n\n                    self.ret_search_container_autocomplete.pack_forget()\n                    self.ret_search_container_canvas[\"height\"]=0\n                    self.ret_search_container_canvas[\"width\"]=0\n        \n    def selection(self, event):\n        if self.lb_up:\n            self.ret_bookID_var.set(self.lb.get(tk.ACTIVE))\n\n            book_title_fetch = c.execute('SELECT title FROM Books WHERE bookID=?',(self.ret_bookID_var.get(),)).fetchall()\n            book_title = [x[0] for x in book_title_fetch][0]\n\n            book_author_fetch = c.execute('SELECT author FROM Books WHERE bookID=?',(self.ret_bookID_var.get(),)).fetchall()\n            book_author = [x[0] for x in book_author_fetch][0]\n\n            #Fetch return date from table\n            return_date_fetch = c.execute('SELECT return_date FROM MyBooks WHERE bookID=?',(self.ret_bookID_var.get(),)).fetchall()\n            return_date = [x[0] for x in return_date_fetch][0]\n\n            self.ret_title_var.set(book_title)\n            self.ret_author_var.set(book_author)\n            self.ret_date_entry.set_date(datetime.strptime(return_date, '%d-%m-%Y'))\n\n            self.ret_search_container_autocomplete.pack_forget()\n            self.ret_search_container_canvas[\"height\"]=0\n            self.ret_search_container_canvas[\"width\"]=0\n\n            self.lb.destroy()\n            self.lb_up = False\n            self.icursor(tk.END)\n\n    def up(self, event):\n        if self.lb_up:\n            if self.lb.curselection() == ():\n                index = '0'\n            else:\n                index = self.lb.curselection()[0]\n\n            if index != '0':                \n                self.lb.selection_clear(first=index)\n                index = str(int(index)-1)  \n\n                self.lb.see(index)\n                self.lb.selection_set(first=index)\n                self.lb.activate(index) \n\n    def down(self, event):\n        if self.lb_up:\n            if self.lb.curselection() == ():\n                index = '0'\n            else:\n                index = self.lb.curselection()[0]\n            if index != tk.END:                        \n                self.lb.selection_clear(first=index)\n                index = str(int(index)+1)\n\n                self.lb.see(index)    \n                self.lb.selection_set(first=index)\n                self.lb.activate(index)\n\n    def comparison(self):\n        pattern = re.compile('.*' + self.ret_bookID_var.get() + '.*')\n        return [w for w in self.listb if re.match(pattern, str(w))]\n\n\n\n\nclass AutoCompleteEntryBD_IssueBookID(ttk.Entry):\n    def __init__(self, search_container_autocomplete, title_entry, title_var, author_entry, author_var, bookID_var, bookID_entry, search_container_canvas, *args, **kwargs):\n\n        self.search_container_autocomplete = search_container_autocomplete\n        self.search_container_canvas = search_container_canvas\n\n        self.title_entry = title_entry\n        self.author_entry = author_entry\n\n        # Listbox length\n        if 'listboxLength' in kwargs:\n            self.listboxLength = kwargs['listboxLength']\n            del kwargs['listboxLength']\n        else:\n            self.listboxLength = 8\n\n        ttk.Entry.__init__(self, *args, **kwargs)\n        self.focus()\n\n        #Titles\n        c.execute(\"SELECT bookID FROM Books WHERE issued=0\")\n        books_bookIDs_fetch = c.fetchall()\n        book_bookIDs_list = [x[0] for x in books_bookIDs_fetch]\n\n        self.lista = book_bookIDs_list\n\n        self.bookID_var = bookID_var\n        self.title_var = title_var\n        self.author_var = author_var\n\n        self.bookID_entry = self[\"textvariable\"]\n        if self.bookID_entry == '':\n            self.bookID_entry = self[\"textvariable\"] = tk.StringVar()\n\n        self.bookID_var.trace('w', self.changed)\n        self.bind(\"<Right>\", self.selection)\n        self.bind(\"<Up>\", self.up)\n        self.bind(\"<Down>\", self.down)\n        \n        self.lb_up = False\n\n    def changed(self, name, index, mode):\n        #Titles\n        c.execute(\"SELECT bookID FROM Books WHERE issued=0\")\n        books_bookID_fetch = c.fetchall()\n        book_bookID_list = [x[0] for x in books_bookID_fetch]\n\n        self.lista = book_bookID_list\n\n        if self.search_container_autocomplete.winfo_ismapped() == False:\n            self.search_container_autocomplete.pack(anchor=tk.W, fill=tk.X, side=tk.TOP)\n\n\n        if self.bookID_var.get() == '':\n            if self.lb_up:\n                self.lb.destroy()\n                self.lb_up = False\n\n        else:\n            words = self.comparison()\n            if words:\n                if not self.lb_up:\n                    self.lb = tk.Listbox(self.search_container_canvas, width=self[\"width\"], height=self.listboxLength)\n                    self.lb.bind(\"<Double-Button-1>\", self.selection)\n                    self.lb.bind(\"<Right>\", self.selection)\n                    self.lb.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n                    self.lb_up = True\n\n                self.lb.delete(0, tk.END)\n                \n\n                for w in words:\n                    self.lb.insert(tk.END,w)\n\n            else:\n                if self.lb_up:\n                    self.lb.destroy()\n                    self.lb_up = False\n\n                    self.search_container_autocomplete.pack_forget()\n                    self.search_container_canvas[\"height\"]=0\n                    self.search_container_canvas[\"width\"]=0\n        \n    def selection(self, event):\n        if self.lb_up:\n            self.bookID_var.set(self.lb.get(tk.ACTIVE))\n\n            book_title_fetch = c.execute('SELECT title FROM Books WHERE bookID=?',(self.bookID_var.get(),)).fetchall()\n            book_title = [x[0] for x in book_title_fetch][0]\n\n            book_author_fetch = c.execute('SELECT author FROM Books WHERE bookID=?',(self.bookID_var.get(),)).fetchall()\n            book_author = [x[0] for x in book_author_fetch][0]\n\n            self.title_var.set(book_title)\n            self.author_var.set(book_author)\n\n            self.search_container_autocomplete.pack_forget()\n            self.search_container_canvas[\"height\"]=0\n            self.search_container_canvas[\"width\"]=0\n\n\n            self.lb.destroy()\n            self.lb_up = False\n            self.icursor(tk.END)\n\n    def up(self, event):\n        if self.lb_up:\n            if self.lb.curselection() == ():\n                index = '0'\n            else:\n                index = self.lb.curselection()[0]\n\n            if index != '0':                \n                self.lb.selection_clear(first=index)\n                index = str(int(index)-1)  \n\n                self.lb.see(index)\n                self.lb.selection_set(first=index)\n                self.lb.activate(index) \n\n    def down(self, event):\n        if self.lb_up:\n            if self.lb.curselection() == ():\n                index = '0'\n            else:\n                index = self.lb.curselection()[0]\n            if index != tk.END:                        \n                self.lb.selection_clear(first=index)\n                index = str(int(index)+1)\n\n                self.lb.see(index)    \n                self.lb.selection_set(first=index)\n                self.lb.activate(index) \n\n    def comparison(self):\n        pattern = re.compile('.*' + self.bookID_var.get() + '.*')\n        return [w for w in self.lista if re.match(pattern, str(w))]\n\n\nclass AutoCompleteEntryBD_RemoveBookID(ttk.Entry):\n    def __init__(self, remove_container_autocomplete, remove_title_entry, remove_title_var, remove_author_entry, remove_author_var, remove_bookID_var, remove_bookID_entry, remove_genre_var, remove_genre_menu, remove_container_canvas, *args, **kwargs):\n\n        self.remove_container_autocomplete = remove_container_autocomplete\n        self.remove_container_canvas = remove_container_canvas\n        self.remove_title_entry = remove_title_entry\n        self.remove_author_entry = remove_author_entry\n        self.remove_genre_menu = remove_genre_menu\n\n        # Listbox length\n        if 'listboxLength' in kwargs:\n            self.listboxLength = kwargs['listboxLength']\n            del kwargs['listboxLength']\n        else:\n            self.listboxLength = 8\n\n        ttk.Entry.__init__(self, *args, **kwargs)\n        self.focus()\n\n        #Titles\n        c.execute(\"SELECT bookID FROM Books\")\n        remove_books_bookIDs_fetch = c.fetchall()\n        remove_book_bookID_list = [x[0] for x in remove_books_bookIDs_fetch]\n\n        self.lista = remove_book_bookID_list\n\n        self.remove_bookID_var = remove_bookID_var\n        self.remove_title_var = remove_title_var\n        self.remove_author_var = remove_author_var\n        self.remove_genre_var = remove_genre_var\n\n        self.remove_bookID_entry = self[\"textvariable\"]\n        if self.remove_bookID_entry == '':\n            self.remove_bookID_entry = self[\"textvariable\"] = tk.StringVar()\n\n        self.remove_bookID_var.trace('w', self.changed)\n        self.bind(\"<Right>\", self.selection)\n        self.bind(\"<Up>\", self.up)\n        self.bind(\"<Down>\", self.down)\n        \n        self.lb_up = False\n\n    def changed(self, name, index, mode):\n        #Titles\n        c.execute(\"SELECT bookID FROM Books\")\n        books_bookID_fetch = c.fetchall()\n        remove_book_bookID_list = [x[0] for x in books_bookID_fetch]\n\n        self.lista = remove_book_bookID_list\n\n        if self.remove_container_autocomplete.winfo_ismapped() == False:\n            self.remove_container_autocomplete.pack(anchor=tk.W, fill=tk.X, side=tk.TOP)\n\n        if self.remove_bookID_var.get() == '':\n            if self.lb_up:\n                self.lb.destroy()\n                self.lb_up = False\n        else:\n            words = self.comparison()\n            if words:            \n                if not self.lb_up:\n                    self.lb = tk.Listbox(self.remove_container_canvas, width=self[\"width\"], height=self.listboxLength)\n                    self.lb.bind(\"<Double-Button-1>\", self.selection)\n                    self.lb.bind(\"<Right>\", self.selection)\n                    self.lb.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n                    self.lb_up = True\n\n                self.lb.delete(0, tk.END)\n                for w in words:\n                    self.lb.insert(tk.END,w)\n            else:\n                if self.lb_up:\n                    self.lb.destroy()\n                    self.lb_up = False\n\n                    self.remove_container_autocomplete.pack_forget()\n                    self.remove_container_canvas[\"height\"]=0\n                    self.remove_container_canvas[\"width\"]=0\n        \n    def selection(self, event):\n        if self.lb_up:\n            self.remove_bookID_var.set(self.lb.get(tk.ACTIVE))\n\n            remove_book_title_fetch = c.execute('SELECT title FROM Books WHERE bookID=?',(self.remove_bookID_var.get(),)).fetchall()\n            remove_book_title = [x[0] for x in remove_book_title_fetch][0]\n\n            remove_book_author_fetch = c.execute('SELECT author FROM Books WHERE bookID=?',(self.remove_bookID_var.get(),)).fetchall()\n            remove_book_author = [x[0] for x in remove_book_author_fetch][0]\n\n            remove_book_genre_fetch = c.execute('SELECT genre FROM Books WHERE bookID=?',(self.remove_bookID_var.get(),)).fetchall()\n            remove_book_genre = [x[0] for x in remove_book_genre_fetch][0]\n\n            self.remove_title_var.set(remove_book_title)\n            self.remove_author_var.set(remove_book_author)\n            self.remove_genre_var.set(remove_book_genre)\n\n            self.remove_container_autocomplete.pack_forget()\n            self.remove_container_canvas[\"height\"]=0\n            self.remove_container_canvas[\"width\"]=0\n\n\n            self.lb.destroy()\n            self.lb_up = False\n            self.icursor(tk.END)\n\n    def up(self, event):\n        if self.lb_up:\n            if self.lb.curselection() == ():\n                index = '0'\n            else:\n                index = self.lb.curselection()[0]\n\n            if index != '0':                \n                self.lb.selection_clear(first=index)\n                index = str(int(index)-1)  \n\n                self.lb.see(index)\n                self.lb.selection_set(first=index)\n                self.lb.activate(index) \n\n    def down(self, event):\n        if self.lb_up:\n            if self.lb.curselection() == ():\n                index = '0'\n            else:\n                index = self.lb.curselection()[0]\n            if index != tk.END:                        \n                self.lb.selection_clear(first=index)\n                index = str(int(index)+1)\n\n                self.lb.see(index)    \n                self.lb.selection_set(first=index)\n                self.lb.activate(index) \n\n    def comparison(self):\n        pattern = re.compile('.*' + self.remove_bookID_var.get() + '.*')\n        return [w for w in self.lista if re.match(pattern, str(w))]\n\n\nclass Library():\n    #USER ACCESS\n    #Look for more books in the database (VIEW ONLY).\n    def __init__(self, root, notebook):\n        self.tree_ids = [] #creates a list to store the ids of each entry in the tree\n\n        library_page = tk.Frame(notebook)\n        notebook.add(library_page, text='Library')\n\n        notebook.bind(\"<<NotebookTabChanged>>\", self.notebook_tab_change)\n\n        header_frame = tk.Frame(library_page)\n        header_frame.pack(fill=tk.X, side=tk.TOP)\n\n        header = tk.Label(header_frame, text='Library', font='System 30')\n        header.pack(side=tk.TOP)\n\n        # Library TreeView Book Database Frame\n        tree_container = tk.Frame(library_page, bg=bg)\n        tree_container.pack(side=tk.RIGHT, anchor=tk.N, padx=padx)\n\n        tree_header = tk.Label(tree_container, text='Database', font='System 18', bg=bg)\n        tree_header.pack(padx=padx, pady=pady)\n\n        #Set up TreeView table\n        self.columns = ('Book ID','Title', 'Author', 'Genre','Location')\n        self.tree = ttk.Treeview(tree_container, columns=self.columns, show='headings') #create tree\n        self.tree.heading(\"Book ID\", text='Book ID')\n        self.tree.heading(\"Title\", text='Title')\n        self.tree.heading(\"Author\", text='Author')\n        self.tree.heading(\"Genre\", text='Genre')\n        self.tree.heading(\"Location\", text='Location')\n\n        self.tree.column(\"Book ID\", width=width, anchor=tk.CENTER)\n        self.tree.column(\"Title\", width=width, anchor=tk.CENTER)\n        self.tree.column(\"Author\", width=width, anchor=tk.CENTER)\n        self.tree.column(\"Genre\", width=width, anchor=tk.CENTER)\n        self.tree.column(\"Location\", width=width, anchor=tk.CENTER)\n\n        #Library Book Database Filters Frame\n        filter_container = tk.Frame(library_page, bg=bg)\n        filter_container.pack(side=tk.LEFT, anchor=tk.N, padx=padx, pady=pady)\n\n        filter_header = tk.Label(filter_container, text='Filters', font='System 18', bg=bg)\n        filter_header.pack(anchor=tk.W, padx=padx, pady=pady)\n\n\n        #BookID Filter\n        search_container_bookID = tk.Frame(filter_container, bg=bg)\n        search_container_bookID.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        bookID_label = tk.Label(search_container_bookID, text='Book ID: ', bg=bg)\n        bookID_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.bookID_reg = root.register(self.bookID_validate)\n\n        self._detached = set()\n        self.bookID_var = tk.StringVar() #create stringvar for entry widget\n        self.bookID_var.trace(\"w\", self._columns_searcher_bookID) #callback if stringvar is updated\n\n        self.bookID_entry = ttk.Entry(search_container_bookID) #create entry\n        self.bookID_entry.config(textvariable=self.bookID_var, validate=\"key\",\n                            validatecommand=(self.bookID_reg, \"%P\"))\n\n        self.bookID_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Title Filter\n        search_container_title = tk.Frame(filter_container, bg=bg)\n        search_container_title.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        title_label = tk.Label(search_container_title, text='Title: ', bg=bg)\n        title_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self._detached = set()\n        self.title_var = tk.StringVar() #create stringvar for entry widget\n        self.title_var.trace(\"w\", self._columns_searcher_title) #callback if stringvar is updated\n\n        self.title_entry = ttk.Entry(search_container_title, textvariable=self.title_var) #create entry\n\n        self.title_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Author Filter\n        search_author_container = tk.Frame(filter_container, bg=bg)\n        search_author_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        author_filter_label = tk.Label(search_author_container, text='Author:', bg=bg)\n        author_filter_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.author_var = tk.StringVar()\n        self.author_var.trace(\"w\", self._columns_searcher_author)\n\n        self.author_entry = ttk.Entry(search_author_container, textvariable=self.author_var, font='System 6')\n        self.author_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Genre Filter\n        genre_filter_label = tk.Label(filter_container, text='Genre:', bg=bg)\n        genre_filter_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.genre_var = tk.StringVar()\n        self.genre_var.set(\"-EMPTY-\")\n        self.genre_var.trace(\"w\", self._columns_searcher_genre)\n\n        self.genre_menu = ttk.OptionMenu(filter_container, self.genre_var,genre_choice_list[0], *genre_choice_list)\n        self.genre_menu.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        #location Filter\n        location_filter_label = tk.Label(filter_container, text='Location:', bg=bg)\n        location_filter_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.location_var = tk.StringVar()\n        self.location_var.set(\"-EMPTY-\")\n        self.location_var.trace(\"w\", self._columns_searcher_location)\n\n        self.location_menu = ttk.OptionMenu(filter_container, self.location_var,location_choice_list[0], *location_choice_list)\n        self.location_menu.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n    def notebook_tab_change(self, event):\n        #gather db info to check if book has been issued, so that we only show the books that have NOT been issued.\n\n        #BookIDs\n        c.execute(\"SELECT bookID FROM Books WHERE issued=0\")\n        non_issued_bookIDs_fetch = c.fetchall()\n        non_issued_bookID_list = [x[0] for x in non_issued_bookIDs_fetch]\n\n        c.execute(\"SELECT title FROM Books WHERE issued=0\")\n        non_issued_title_fetch = c.fetchall()\n        non_issued_title_list = [x[0] for x in non_issued_title_fetch]\n\n        #Authors\n        c.execute(\"SELECT author FROM Books WHERE issued=0\")\n        non_issued_author_fetch = c.fetchall()\n        non_issued_author_list = [x[0] for x in non_issued_author_fetch]\n\n        #Genres\n        c.execute(\"SELECT genre FROM Books WHERE issued=0\")\n        non_issued_genre_fetch = c.fetchall()\n        non_issued_genre_list = [x[0] for x in non_issued_genre_fetch]\n\n        #Locations\n        c.execute('SELECT location FROM Books WHERE issued=0')\n        non_issued_location_fetch = c.fetchall()\n        non_issued_location_list = [x[0] for x in non_issued_location_fetch]\n\n\n        for k in self.tree.get_children():\n            self.tree.delete(k)\n\n        for i in range(len(non_issued_bookID_list)):\n            #creates an entry in the tree for each element of the list\n            #then stores the id of the tree in the self.ids list\n            self.tree_ids.append(self.tree.insert(\"\", \"end\", values=(non_issued_bookID_list[i], non_issued_title_list[i], non_issued_author_list[i], non_issued_genre_list[i], non_issued_location_list[i])))\n        self.tree.pack()\n\n        #Update Genre List for OptionMenu\n        c.execute(\"SELECT genre FROM Genres\")\n        genres_list_fetch = c.fetchall()\n        genre_choice_list = [x[0] for x in genres_list_fetch]\n\n        genre_menu = self.genre_menu[\"menu\"]\n        genre_menu.delete(0, tk.END)\n        for string in genre_choice_list:\n            genre_menu.add_command(label=string,\n                             command=lambda value=string: self.genre_var.set(value))\n\n    def bookID_validate(self, bookID_input):\n        if bookID_input.isdigit():\n            return True\n        elif bookID_input is \"\":\n            return True\n        else:\n            return False\n\n\n\n\n    # Works, but all filters are independent from each other, meaning if you search for a title and then enter a completely unrelated author, it will search\n    # for the last key field entered search. So the author's books would show up, with no relation to the Title searched.\n    # Improvement: Allow for the filters to be dependant on each other, eg. search for author 'John', and one of his books called 'Test' amongst other books he\n    # may have released under different titles.\n    def _columns_searcher_bookID(self, *args):\n        children = list(self._detached) + list(self.tree.get_children())\n        self._detached = set()\n        query_bookID = self.bookID_entry.get()\n\n        self.search_bookID_tv(children, query_bookID)\n\n    def _columns_searcher_title(self, *args):\n        children = list(self._detached) + list(self.tree.get_children())\n        self._detached = set()\n        query_title = self.title_entry.get()\n\n        self.search_title_tv(children, query_title)\n\n    def _columns_searcher_author(self, *args):\n        children = list(self._detached) + list(self.tree.get_children())\n        self._detached = set()\n        query_author = self.author_entry.get()\n\n        self.search_author_tv(children, query_author)\n\n    def _columns_searcher_genre(self, *args):\n        children = list(self._detached) + list(self.tree.get_children())\n        self._detached = set()\n        query_genre = self.genre_var.get()\n\n        self.search_genre_tv(children, query_genre)\n\n    def _columns_searcher_location(self, *args):\n        children = list(self._detached) + list(self.tree.get_children())\n        self._detached = set()\n        query_location = self.location_var.get()\n\n        self.search_genre_tv(children, query_location)\n\n    def search_bookID_tv(self, children, query_bookID):\n        i_r = -1\n\n        for item_id in children:\n            bookID_text = str(self.tree.item(item_id)['values'][0])\n\n            if query_bookID in bookID_text:\n                i_r += 1\n                self.tree.reattach(item_id, '', i_r)\n\n            else:\n                self._detached.add(item_id)\n                self.tree.detach(item_id)\n\n    def search_title_tv(self, children, query_title):\n        i_r = -1\n\n        for item_id in children:\n            title_text = self.tree.item(item_id)['values'][1]\n\n            if query_title in title_text:\n                i_r += 1\n                self.tree.reattach(item_id, '', i_r)\n\n            else:\n                self._detached.add(item_id)\n                self.tree.detach(item_id)\n\n    def search_author_tv(self, children, query_author):\n        i_r = -1\n\n        for item_id in children:\n            author_text = self.tree.item(item_id)['values'][2]\n\n            if query_author in author_text:\n                i_r += 1\n                self.tree.reattach(item_id, '', i_r)\n\n            else:\n                self._detached.add(item_id)\n                self.tree.detach(item_id)\n\n    def search_genre_tv(self, children, query_genre):\n        i_r = -1\n\n        for item_id in children:\n            genre_text = self.tree.item(item_id)['values'][3]\n\n            if query_genre in genre_text:\n                i_r += 1\n                self.tree.reattach(item_id, '', i_r)\n\n            elif query_genre == '-EMPTY-':\n                self.tree.reattach(item_id, '', i_r)\n\n            else:\n                self._detached.add(item_id)\n                self.tree.detach(item_id)\n\n    def search_location_tv(self, children, query_location):\n        i_r = -1\n\n        for item_id in children:\n            location_text = self.tree.item(item_id)['values'][3]\n\n            if query_location in location_text:\n                i_r += 1\n                self.tree.reattach(item_id, '', i_r)\n\n            elif query_location == '-EMPTY-':\n                self.tree.reattach(item_id, '', i_r)\n\n            else:\n                self._detached.add(item_id)\n                self.tree.detach(item_id)\n\n\n\nclass MyBooks():\n    #USER ACCESS\n    #Display logged in user's books taken out.\n    def __init__(self, root, notebook, current_user_email):\n        self.user_email = current_user_email\n        self.tree_ids = [] \n\n        my_books_page = tk.Frame(notebook)\n        notebook.add(my_books_page, text='My Books')\n\n        header_frame = tk.Frame(my_books_page)\n        header_frame.pack(fill=tk.X, side=tk.TOP)\n\n        header = tk.Label(header_frame, text='My Books', font='System 30')\n        header.pack(side=tk.TOP)\n\n        # Library TreeView Book Database Frame\n        tree_container = tk.Frame(my_books_page)\n        tree_container.pack(side=tk.RIGHT, anchor=tk.N, padx=padx)\n\n        tree_header = tk.Label(tree_container, text='Database', font='System 18', bg=bg)\n        tree_header.pack(padx=padx, pady=pady)\n\n        #Set up TreeView table\n        self.columns = ('Book ID','Title', 'Author', 'Genre','Location')\n        self.tree = ttk.Treeview(tree_container, columns=self.columns, show='headings') #create tree\n        self.tree.heading(\"Book ID\", text='Book ID')\n        self.tree.heading(\"Title\", text='Title')\n        self.tree.heading(\"Author\", text='Author')\n        self.tree.heading(\"Genre\", text='Genre')\n        self.tree.heading(\"Location\", text='Location')\n\n        self.tree.column(\"Book ID\", width=width, anchor=tk.CENTER)\n        self.tree.column(\"Title\", width=width, anchor=tk.CENTER)\n        self.tree.column(\"Author\", width=width, anchor=tk.CENTER)\n        self.tree.column(\"Genre\", width=width, anchor=tk.CENTER)\n        self.tree.column(\"Location\", width=width, anchor=tk.CENTER)\n\n        #BookIDs\n        c.execute(\"\"\"SELECT Books.bookID\n            FROM MyBooks\n            INNER JOIN Books\n            ON MyBooks.bookID = Books.bookID\n            INNER JOIN Accounts\n            ON MyBooks.my_booksID = Accounts.my_booksID\n            WHERE Accounts.my_booksID = (SELECT my_booksID FROM Accounts WHERE email_address=?)\"\"\",(self.user_email,))\n        user_books_bookIDs_fetch = c.fetchall()\n        user_book_bookID_list = [x[0] for x in user_books_bookIDs_fetch]\n\n\n        #Titles\n        c.execute(\"\"\"SELECT Books.title\n            FROM MyBooks\n            INNER JOIN Books\n            ON MyBooks.bookID = Books.bookID\n            INNER JOIN Accounts\n            ON MyBooks.my_booksID = Accounts.my_booksID\n            WHERE Accounts.my_booksID = (SELECT my_booksID FROM Accounts WHERE email_address=?)\"\"\",(self.user_email,))\n        user_books_title_fetch = c.fetchall()\n        user_book_title_list = [x[0] for x in user_books_title_fetch]\n\n\n        #Authors\n        c.execute(\"\"\"SELECT Books.author\n            FROM MyBooks\n            INNER JOIN Books\n            ON MyBooks.bookID = Books.bookID\n            INNER JOIN Accounts\n            ON MyBooks.my_booksID = Accounts.my_booksID\n            WHERE Accounts.my_booksID = (SELECT my_booksID FROM Accounts WHERE email_address=?)\"\"\",(self.user_email,))\n        user_books_author_fetch = c.fetchall()\n        user_book_author_list = [x[0] for x in user_books_author_fetch]\n\n\n        #Genres\n        c.execute(\"\"\"SELECT Books.genre\n            FROM MyBooks\n            INNER JOIN Books\n            ON MyBooks.bookID = Books.bookID\n            INNER JOIN Accounts\n            ON MyBooks.my_booksID = Accounts.my_booksID\n            WHERE Accounts.my_booksID = (SELECT my_booksID FROM Accounts WHERE email_address=?)\"\"\",(self.user_email,))\n        user_books_genre_fetch = c.fetchall()\n        user_book_genre_list = [x[0] for x in user_books_genre_fetch]\n\n        for i in range(len(user_book_bookID_list)):\n            #creates an entry in the tree for each element of the list\n            #then stores the id of the tree in the self.ids list\n            self.tree_ids.append(self.tree.insert(\"\", \"end\", values=(user_book_bookID_list[i], user_book_title_list[i], user_book_author_list[i], user_book_genre_list[i])))\n        self.tree.pack()\n\n        #Search Books UI\n        filter_container = tk.Frame(my_books_page, bg=bg)\n        filter_container.pack(side=tk.LEFT, anchor=tk.N, padx=padx, pady=pady)\n\n        filter_header = tk.Label(filter_container, text='Filters', font='System 18', bg=bg)\n        filter_header.pack(anchor=tk.W, padx=padx, pady=pady)\n\n\n        #BookIDs Filter\n        search_container_bookID = tk.Frame(filter_container, bg=bg)\n        search_container_bookID.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        bookID_label = tk.Label(search_container_bookID, text='Book ID: ', bg=bg)\n        bookID_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.bookID_reg = root.register(self.bookID_validate)\n\n        self._detached = set()\n        self.bookID_var = tk.StringVar() #create stringvar for entry widget\n        self.bookID_var.trace(\"w\", self._columns_searcher_bookID) #callback if stringvar is updated\n\n        self.bookID_entry = ttk.Entry(search_container_bookID)\n        self.bookID_entry.config(textvariable=self.bookID_var, validate=\"key\",\n                            validatecommand=(self.bookID_reg, \"%P\"))\n        self.bookID_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Titles Filter\n        search_container_title = tk.Frame(filter_container, bg=bg)\n        search_container_title.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        title_label = tk.Label(search_container_title, text='Title: ', bg=bg)\n        title_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self._detached = set()\n        self.title_var = tk.StringVar() #create stringvar for entry widget\n        self.title_var.trace(\"w\", self._columns_searcher_title) #callback if stringvar is updated\n\n        self.title_entry = ttk.Entry(search_container_title, textvariable=self.title_var)\n        self.title_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Author Filter\n        search_container_author = tk.Frame(filter_container, bg=bg)\n        search_container_author.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        author_label = tk.Label(search_container_author, text='Author: ', bg=bg)\n        author_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self._detached = set()\n        self.author_var = tk.StringVar() #create stringvar for entry widget\n        self.author_var.trace(\"w\", self._columns_searcher_author) #callback if stringvar is updated\n\n        self.author_entry = ttk.Entry(search_container_author, textvariable=self.author_var)\n        self.author_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n        #Genre Filter\n        search_container_genre = tk.Frame(filter_container, bg=bg)\n        search_container_genre.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        genre_label = tk.Label(search_container_genre, text='Genre:', bg=bg)\n        genre_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.genre_var = tk.StringVar()\n        self.genre_var.set(\"-EMPTY-\")\n        self.genre_var.trace(\"w\", self._columns_searcher_genre)\n\n        self.genre_menu = ttk.OptionMenu(search_container_genre, self.genre_var,genre_choice_list[0], *genre_choice_list)\n        self.genre_menu.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        #Location Filter\n        search_container_location = tk.Frame(filter_container, bg=bg)\n        search_container_location.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        location_label = tk.Label(search_container_location, text='Location:', bg=bg)\n        location_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.location_var = tk.StringVar()\n        self.location_var.set(\"-EMPTY-\")\n        self.location_var.trace(\"w\", self._columns_searcher_location)\n\n        self.location_menu = ttk.OptionMenu(search_container_location, self.location_var,location_choice_list[0], *location_choice_list)\n        self.location_menu.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n\n        refresh_container = tk.Frame(filter_container, bg=bg)\n        refresh_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        refresh_label = tk.Label(refresh_container, text='Update Page Values: ', bg=bg)\n        refresh_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        refresh_button = ttk.Button(refresh_container, text='Refresh', command=self.refresh_page)\n        refresh_button.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        root.bind(\"<F5>\", self.refresh_page)\n\n    def refresh_page(self, *args):\n        for k in self.tree.get_children():\n            self.tree.delete(k)\n\n        #BookIDs\n        c.execute(\"\"\"SELECT Books.bookID\n            FROM MyBooks\n            INNER JOIN Books\n            ON MyBooks.bookID = Books.bookID\n            INNER JOIN Accounts\n            ON MyBooks.my_booksID = Accounts.my_booksID\n            WHERE Accounts.my_booksID = (SELECT my_booksID FROM Accounts WHERE email_address=?)\"\"\",(self.user_email,))\n        user_books_bookIDs_fetch = c.fetchall()\n        user_book_bookID_list = [x[0] for x in user_books_bookIDs_fetch]\n\n\n        #Titles\n        c.execute(\"\"\"SELECT Books.title\n            FROM MyBooks\n            INNER JOIN Books\n            ON MyBooks.bookID = Books.bookID\n            INNER JOIN Accounts\n            ON MyBooks.my_booksID = Accounts.my_booksID\n            WHERE Accounts.my_booksID = (SELECT my_booksID FROM Accounts WHERE email_address=?)\"\"\",(self.user_email,))\n        user_books_title_fetch = c.fetchall()\n        user_book_title_list = [x[0] for x in user_books_title_fetch]\n\n\n        #Authors\n        c.execute(\"\"\"SELECT Books.author\n            FROM MyBooks\n            INNER JOIN Books\n            ON MyBooks.bookID = Books.bookID\n            INNER JOIN Accounts\n            ON MyBooks.my_booksID = Accounts.my_booksID\n            WHERE Accounts.my_booksID = (SELECT my_booksID FROM Accounts WHERE email_address=?)\"\"\",(self.user_email,))\n        user_books_author_fetch = c.fetchall()\n        user_book_author_list = [x[0] for x in user_books_author_fetch]\n\n\n        #Genres\n        c.execute(\"\"\"SELECT Books.genre\n            FROM MyBooks\n            INNER JOIN Books\n            ON MyBooks.bookID = Books.bookID\n            INNER JOIN Accounts\n            ON MyBooks.my_booksID = Accounts.my_booksID\n            WHERE Accounts.my_booksID = (SELECT my_booksID FROM Accounts WHERE email_address=?)\"\"\",(self.user_email,))\n        user_books_genre_fetch = c.fetchall()\n        user_book_genre_list = [x[0] for x in user_books_genre_fetch]\n\n        #Location\n        c.execute(\"\"\"SELECT Books.location\n            FROM MyBooks\n            INNER JOIN Books\n            ON MyBooks.bookID = Books.bookID\n            INNER JOIN Accounts\n            ON MyBooks.my_booksID = Accounts.my_booksID\n            WHERE Accounts.my_booksID = (SELECT my_booksID FROM Accounts WHERE email_address=?)\"\"\",(self.user_email,))\n        user_books_location_fetch = c.fetchall()\n        user_book_location_list = [x[0] for x in user_books_location_fetch]\n\n        for i in range(len(user_book_bookID_list)):\n            #creates an entry in the tree for each element of the list\n            #then stores the id of the tree in the self.ids list\n            self.tree_ids.append(self.tree.insert(\"\", \"end\", values=(user_book_bookID_list[i], user_book_title_list[i], user_book_author_list[i], user_book_genre_list[i], user_book_location_list[i])))\n        self.tree.pack()\n\n        #Update Genre List for OptionMenu\n        c.execute(\"SELECT genre FROM Genres\")\n        genres_list_fetch = c.fetchall()\n        genre_choice_list = [x[0] for x in genres_list_fetch]\n\n        genre_menu = self.genre_menu[\"menu\"]\n        genre_menu.delete(0, tk.END)\n        for string in genre_choice_list:\n            genre_menu.add_command(label=string,\n                             command=lambda value=string: self.genre_var.set(value))\n\n        #Update location List for OptionMenu\n        c.execute(\"SELECT location FROM Books\")\n        locations_list_fetch = c.fetchall()\n        location_choice_list = [x[0] for x in locations_list_fetch]\n\n        location_menu = self.location_menu[\"menu\"]\n        location_menu.delete(0, tk.END)\n        for string in location_choice_list:\n            location_menu.add_command(label=string,\n                             command=lambda value=string: self.location_var.set(value))\n\n\n        ms.showinfo('Success','You have refreshed the My Books Page!')\n\n    def bookID_validate(self, bookID_input):\n        if bookID_input.isdigit():\n            return True\n        elif bookID_input is \"\":\n            return True\n        else:\n            return False\n\n    def _columns_searcher_bookID(self, *args):\n        children = list(self._detached) + list(self.tree.get_children())\n        self._detached = set()\n        query_bookID = self.bookID_entry.get()\n\n        self.search_bookID_tv(children, query_bookID)\n\n    def _columns_searcher_title(self, *args):\n        children = list(self._detached) + list(self.tree.get_children())\n        self._detached = set()\n        query_title = self.title_entry.get()\n\n        self.search_title_tv(children, query_title)\n\n    def _columns_searcher_author(self, *args):\n        children = list(self._detached) + list(self.tree.get_children())\n        self._detached = set()\n        query_author = self.author_entry.get()\n\n        self.search_author_tv(children, query_author)\n\n    def _columns_searcher_genre(self, *args):\n        children = list(self._detached) + list(self.tree.get_children())\n        self._detached = set()\n        query_genre = self.genre_var.get()\n\n        self.search_genre_tv(children, query_genre)\n\n    def _columns_searcher_location(self, *args):\n        children = list(self._detached) + list(self.tree.get_children())\n        self._detached = set()\n        query_location = self.location_var.get()\n\n        self.search_location_tv(children, query_location)\n\n    def search_bookID_tv(self, children, query_bookID):\n        i_r = -1\n\n        for item_id in children:\n            bookID_text = str(self.tree.item(item_id)['values'][0])\n\n            if query_bookID in bookID_text:\n                i_r += 1\n                self.tree.reattach(item_id, '', i_r)\n\n            else:\n                self._detached.add(item_id)\n                self.tree.detach(item_id)\n\n    def search_title_tv(self, children, query_title):\n        i_r = -1\n\n        for item_id in children:\n            title_text = self.tree.item(item_id)['values'][1]\n\n            if query_title in title_text:\n                i_r += 1\n                self.tree.reattach(item_id, '', i_r)\n\n            else:\n                self._detached.add(item_id)\n                self.tree.detach(item_id)\n\n    def search_author_tv(self, children, query_author):\n        i_r = -1\n\n        for item_id in children:\n            author_text = self.tree.item(item_id)['values'][2]\n\n            if query_author in author_text:\n                i_r += 1\n                self.tree.reattach(item_id, '', i_r)\n\n            else:\n                self._detached.add(item_id)\n                self.tree.detach(item_id)\n\n    def search_genre_tv(self, children, query_genre):\n        i_r = -1\n\n        for item_id in children:\n            genre_text = self.tree.item(item_id)['values'][3]\n\n            if query_genre in genre_text:\n                i_r += 1\n                self.tree.reattach(item_id, '', i_r)\n\n            elif query_genre == '-EMPTY-':\n                self.tree.reattach(item_id, '', i_r)\n\n            else:\n                self._detached.add(item_id)\n                self.tree.detach(item_id)\n\n    def search_location_tv(self, children, query_location):\n        i_r = -1\n\n        for item_id in children:\n            location_text = self.tree.item(item_id)['values'][3]\n\n            if query_location in location_text:\n                i_r += 1\n                self.tree.reattach(item_id, '', i_r)\n\n            elif query_location == '-EMPTY-':\n                self.tree.reattach(item_id, '', i_r)\n\n            else:\n                self._detached.add(item_id)\n                self.tree.detach(item_id)\n\n\nclass AutoCompleteEntryMB():\n    def __init__(self, search_container_title, current_user_email, *args, **kwargs):\n\n        self.search_container_title = search_container_title\n        self.user_email = current_user_email\n        #Titles\n        c.execute(\"\"\"SELECT Books.title\n            FROM MyBooks\n            INNER JOIN Books\n            ON MyBooks.bookID = Books.bookID\n            INNER JOIN Accounts\n            ON MyBooks.my_booksID = Accounts.my_booksID\n            WHERE Accounts.my_booksID = (SELECT my_booksID FROM Accounts WHERE email_address=?)\"\"\",(self.user_email,))\n        user_books_title_fetch = c.fetchall()\n        user_book_title_list = [x[0] for x in user_books_title_fetch]\n\n        self.lista = user_book_title_list   \n        self.var_mb = self.title_entry[\"textvariable\"]\n        if self.var_mb == '':\n            self.var_mb = self.title_entry[\"textvariable\"] = tk.StringVar()\n\n        self.var_mb.trace('w', self.changed)\n        self.title_entry.bind(\"<Right>\", self.selection)\n        self.title_entry.bind(\"<Up>\", self.up)\n        self.title_entry.bind(\"<Down>\", self.down)\n        \n        self.lb_up = False\n\n    def changed(self, name, index, mode):\n        #Titles\n        c.execute(\"\"\"SELECT Books.title\n            FROM MyBooks\n            INNER JOIN Books\n            ON MyBooks.bookID = Books.bookID\n            INNER JOIN Accounts\n            ON MyBooks.my_booksID = Accounts.my_booksID\n            WHERE Accounts.my_booksID = (SELECT my_booksID FROM Accounts WHERE email_address=?)\"\"\",(self.user_email,))\n        user_books_title_fetch = c.fetchall()\n        user_book_title_list = [x[0] for x in user_books_title_fetch]\n\n        self.lista = user_book_title_list  \n\n        if self.var_mb.get() == '':\n            self.lb.destroy()\n            self.lb_up = False\n        else:\n            words = self.comparison()\n            if words:            \n                if not self.lb_up:\n                    self.lb = tk.Listbox(self.search_container_title)\n                    self.lb.bind(\"<Double-Button-1>\", self.selection)\n                    self.lb.bind(\"<Right>\", self.selection)\n                    self.lb.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n                    self.lb_up = True\n                \n                self.lb.delete(0, tk.END)\n                for w in words:\n                    self.lb.insert(tk.END,w)\n            else:\n                if self.lb_up:\n                    self.lb.destroy()\n                    self.lb_up = False\n        \n    def selection(self, event):\n\n        if self.lb_up:\n            self.var_mb.set(self.lb.get(tk.ACTIVE))\n            self.lb.destroy()\n            self.lb_up = False\n            self.title_entry.icursor(tk.END)\n\n    def up(self, event):\n\n        if self.lb_up:\n            if self.lb.curselection() == ():\n                index = '0'\n            else:\n                index = self.lb.curselection()[0]\n            if index != '0':                \n                self.lb.selection_clear(first=index)\n                index = str(int(index)-1)                \n                self.lb.selection_set(first=index)\n                self.lb.activate(index) \n\n    def down(self, event):\n\n        if self.lb_up:\n            if self.lb.curselection() == ():\n                index = '0'\n            else:\n                index = self.lb.curselection()[0]\n            if index != tk.tk.END:                        \n                self.lb.selection_clear(first=index)\n                index = str(int(index)+1)        \n                self.lb.selection_set(first=index)\n                self.lb.activate(index) \n\n    def comparison(self):\n        pattern = re.compile('.*' + self.var_mb.get() + '.*')\n        return [w for w in self.lista if re.match(pattern, w)]\n\n\nclass Account():\n    #USER ACCESS\n    #Display logged in user information.\n    def __init__(self, root, notebook, current_user_email):\n        user_email= current_user_email\n\n        account_page = tk.Frame(notebook)\n        notebook.add(account_page, text='Account')\n\n        header_frame = tk.Frame(account_page)\n        header_frame.pack(fill=tk.X, side=tk.TOP)\n\n        header = tk.Label(header_frame, text='Account', font='System 30')\n        header.pack(side=tk.TOP)\n\n        # Account Details Frame\n        details_container = tk.Frame(account_page, bg=bg)\n        details_container.pack(side=tk.LEFT, anchor=tk.N)\n\n        container_header = tk.Label(details_container, text='Account Details', font='System 18', bg=bg)\n        container_header.pack(anchor=tk.W, padx=padx, pady=pady)\n\n\n        \n        #Change password Container\n        self.change_password_container = tk.Frame(account_page, bg=bg)\n        self.container_change_password_header = tk.Label(self.change_password_container, text='Change Password', font='System 18', bg=bg)\n        \n\n\n\n        #Change password email entry\n        self.change_pw_email_container = tk.Frame(self.change_password_container, bg=bg)\n        self.change_pw_email_label = tk.Label(self.change_pw_email_container, text='Email:',bg=bg)\n        \n\n        self.change_pw_email_var = tk.StringVar()\n        self.change_pw_email_entry = ttk.Entry(self.change_pw_email_container, textvariable=self.change_pw_email_var)\n        \n\n\n\n        #Current password entry\n        self.current_pw_container = tk.Frame(self.change_password_container, bg=bg)\n        self.current_pw_label = tk.Label(self.current_pw_container, text='Current Password:',bg=bg)\n        \n\n        self.current_pw_var = tk.StringVar()\n        self.current_pw_entry = ttk.Entry(self.current_pw_container, textvariable=self.current_pw_var, show='*')\n        \n\n\n\n        #New password entry\n        self.new_pw_container = tk.Frame(self.change_password_container, bg=bg)\n        self.new_pw_label = tk.Label(self.new_pw_container, text='New Password:',bg=bg)\n        \n\n        self.new_pw_var = tk.StringVar()\n        self.new_pw_entry = ttk.Entry(self.new_pw_container, textvariable=self.new_pw_var, show='*')\n        \n\n\n\n        #New password confirmation entry\n        self.new_pw_confirm_container = tk.Frame(self.change_password_container, bg=bg)\n        self.new_pw_confirm_label = tk.Label(self.new_pw_confirm_container, text='Confirm New Password:',bg=bg)\n        \n\n        self.new_pw_confirm_var = tk.StringVar()\n        self.new_pw_confirm_entry = ttk.Entry(self.new_pw_confirm_container, textvariable=self.new_pw_confirm_var, show='*')\n        \n\n        #Change password button\n        self.change_password_button_container = tk.Frame(self.change_password_container, bg=bg)\n        self.change_password_button = ttk.Button(self.change_password_button_container, text='Change Password', command=lambda:self.change_password())\n\n\n\n\n        #Delete Account Container\n        self.delete_account_container = tk.Frame(account_page, bg=bg)\n        self.container_delete_account_header = tk.Label(self.delete_account_container, text='Delete Account', font='System 18', bg=bg)\n        \n\n\n        # Email Container\n        self.delete_acc_email_container = tk.Frame(self.delete_account_container, bg=bg)\n        self.delete_acc_email_label = tk.Label(self.delete_acc_email_container, text='Email:',bg=bg)\n        \n\n        self.delete_acc_pw_email_var = tk.StringVar()\n        self.delete_acc_pw_email_entry = ttk.Entry(self.delete_acc_email_container, textvariable=self.delete_acc_pw_email_var)\n        \n\n\n\n        #Password entry\n        self.pw_container = tk.Frame(self.delete_account_container, bg=bg)\n        self.pw_label = tk.Label(self.pw_container, text='Password:',bg=bg)\n        \n\n        self.pw_var = tk.StringVar()\n        self.pw_entry = ttk.Entry(self.pw_container, textvariable=self.pw_var)\n        \n\n\n\n        #New password entry\n        self.confirm_pw_container = tk.Frame(self.delete_account_container, bg=bg)\n        self.confirm_pw_label = tk.Label(self.confirm_pw_container, text='Confirm Password:',bg=bg)\n        \n\n        self.confirm_pw_var = tk.StringVar()\n        self.confirm_pw_entry = ttk.Entry(self.confirm_pw_container, textvariable=self.confirm_pw_var, show='*')\n\n\n        #Delete account button\n        self.delete_account_button_container = tk.Frame(self.delete_account_container, bg=bg)\n        self.delete_account_button = ttk.Button(self.delete_account_button_container, text='Delete Account', command=lambda:self.deletion_confirmation())\n\n\n\n        \n\n\n\n\n        email_container = tk.Frame(details_container, bg=bg)\n        email_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n\n        email_label = tk.Label(email_container, text='   Email:   {}'.format(user_email), padx=padx, pady=pady)\n        email_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        change_password_label = tk.Label(details_container, text='Change Password?', cursor=\"hand2\",\n                                                bg=bg, fg='blue')\n        change_password_label.pack(anchor=tk.W, padx=padx, pady=pady)\n        change_password_label.bind(\"<Button-1>\", lambda e: self.change_password_container_func())\n\n        delete_account_label = tk.Label(details_container, text='Delete Account?', cursor=\"hand2\",\n                                                bg=bg, fg='orange red')\n        delete_account_label.pack(anchor=tk.W, padx=padx, pady=pady)\n        delete_account_label.bind(\"<Button-1>\", lambda e: self.delete_account_container_func())\n\n    def change_password(self, *args):\n        change_password_confirmation = ms.askquestion('Change Password', 'Are you sure you want to change password?')\n        if change_password_confirmation == 'yes':\n            #Update password in database to fit the new password and its hash\n\n            current_pw = self.current_pw_var.get()\n            new_pw = self.new_pw_var.get()\n            email_address = self.change_pw_email_var.get()\n\n            #Check if the current password entered matches the one stored in the database\n\n            #Hash the password to check against the database one\n            db_current_pw_fetch = c.execute('SELECT password FROM Accounts WHERE email_address = ?', (email_address,))\n            db_current_pw = c.fetchone()[0]\n\n            #Password stored in database\n            db_current_pw_encode = db_current_pw.encode('utf-8')\n\n            #Password userhas just typed in, converted into bytes literal.\n            bytes_current_pw = bytes(current_pw, 'utf-8')\n            \n\n            if bcrypt.checkpw(bytes_current_pw, db_current_pw_encode):\n                #Encrypt+Salt New PW\n                hashable_new_pw = bytes(new_pw, 'utf-8')\n                hashed_new_pw = bcrypt.hashpw(hashable_new_pw, bcrypt.gensalt())\n\n                #Convert into base64string\n                db_hashed_pw = hashed_new_pw.decode(\"utf-8\")\n\n                db_new_pw_update = c.execute('UPDATE Accounts SET password=? WHERE email_address=?',(db_hashed_pw, email_address))\n                conn.commit()\n            else:\n                ms.showerror('Error','Current password does not match.')\n\n    def deletion_confirmation(self, *args):\n        account_deletion_confirmation = ms.askquestion('Account Deletion', 'Are you sure you want to delete your account?\\n\\nYou will not be able to recover any information saved on this account.\\nAll personal information associated to this account will be deleted permanently.')\n        if account_deletion_confirmation == 'yes':\n            #logic for deleting account goes here\n            pass\n\n    def change_password_container_func(self, *args):\n        #If the user has pressed the button after the widgets were already packed, unpack them.\n        if self.change_password_container.winfo_ismapped() == True:\n            #May be able to just use a for loop that iterates over child widget using winfo_children().\n            self.change_password_container.pack_forget()\n            self.container_change_password_header.pack_forget()\n            self.change_pw_email_container.pack_forget()\n            self.change_pw_email_label.pack_forget()\n            self.change_pw_email_entry.pack_forget()\n            self.current_pw_container.pack_forget()\n            self.current_pw_label.pack_forget()\n            self.current_pw_entry.pack_forget()\n            self.new_pw_container.pack_forget()\n            self.new_pw_label.pack_forget()\n            self.new_pw_entry.pack_forget()\n            self.new_pw_confirm_container.pack_forget()\n            self.new_pw_confirm_label.pack_forget()\n            self.new_pw_confirm_entry.pack_forget()\n            self.change_password_button_container.pack_forget()\n            self.change_password_button.pack_forget()\n        else:\n            #Pack all the widgets upon the user pressing the button.\n            self.change_password_container.pack(side=tk.LEFT, anchor=tk.N)\n            self.container_change_password_header.pack(anchor=tk.W, padx=padx, pady=pady)\n            self.change_pw_email_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n            self.change_pw_email_label.pack(side=tk.LEFT, anchor=tk.W, fill=tk.X, padx=padx, pady=pady)\n            self.change_pw_email_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n            self.current_pw_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n            self.current_pw_label.pack(side=tk.LEFT, anchor=tk.W, fill=tk.X, padx=padx, pady=pady)\n            self.current_pw_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n            self.new_pw_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n            self.new_pw_label.pack(side=tk.LEFT, anchor=tk.W, fill=tk.X, padx=padx, pady=pady)\n            self.new_pw_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n            self.new_pw_confirm_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n            self.new_pw_confirm_label.pack(side=tk.LEFT, anchor=tk.W, fill=tk.X, padx=padx, pady=pady)\n            self.new_pw_confirm_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n            self.change_password_button_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n            self.change_password_button.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n    def delete_account_container_func(self, *args):\n        #If the user has pressed the button after the widgets were already packed, unpack them.\n        if self.delete_account_container.winfo_ismapped() == True:\n            self.delete_account_container.pack_forget()\n            self.container_delete_account_header.pack_forget()\n            self.delete_acc_email_container.pack_forget()\n            self.delete_acc_email_label.pack_forget()\n            self.delete_acc_pw_email_entry.pack_forget()\n            self.pw_container.pack_forget()\n            self.pw_label.pack_forget()\n            self.pw_entry.pack_forget()\n            self.confirm_pw_container.pack_forget()\n            self.confirm_pw_label.pack_forget()\n            self.confirm_pw_entry.pack_forget()\n            self.delete_account_button_container.pack_forget()\n            self.delete_account_button.pack_forget()\n        else:\n            #Pack all the widgets to show the panel upon pressing the delete_account box in account details\n            self.delete_account_container.pack(side=tk.LEFT, anchor=tk.N)\n            self.container_delete_account_header.pack(anchor=tk.W, padx=padx, pady=pady)\n            self.delete_acc_email_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n            self.delete_acc_email_label.pack(side=tk.LEFT, anchor=tk.W, fill=tk.X, padx=padx, pady=pady)\n            self.delete_acc_pw_email_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n            self.pw_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n            self.pw_label.pack(side=tk.LEFT, anchor=tk.W, fill=tk.X, padx=padx, pady=pady)\n            self.pw_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n            self.confirm_pw_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n            self.confirm_pw_label.pack(side=tk.LEFT, anchor=tk.W, fill=tk.X, padx=padx, pady=pady)\n            self.confirm_pw_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n            self.delete_account_button_container.pack(anchor=tk.W, fill=tk.X, expand=True, side=tk.TOP)\n            self.delete_account_button.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n       \n\nclass Home():\n    #USER ACCESS\n    #Describe Software Information.\n    def __init__(self, root, notebook):\n        home_page = tk.Frame(notebook)\n        notebook.add(home_page, text='Home')\n\n        home_header = tk.Label(home_page, text='Welcome to the Library System!', font='System 30')\n        home_header.pack(fill=tk.X, expand=True, side=tk.TOP, anchor=tk.N)\n\n\n\n        '''\n        sidebarframe = tk.Frame(root)\n        self.sometext = tk.Text(sidebarframe)\n        button= tk.Button(sidebarframe, text=\"do something\",\n                          command = self.do_something)\n\n        sidebarframe.pack(row = 3, column = 5)\n        self.sometext.pack(row = 3, column = 6)\n        button.pack(row = 3, column = 7)\n\n        self.sometext.focus_set()\n\n    def do_something(self):\n        self.sometext.delete(1.0, \"end\")\n        print (\"do something\")\n        '''\n\nclass ForgotPW():\n    def __init__(self,parent, sign_in_notebook):\n        self.sign_in_notebook = sign_in_notebook\n        forgot_pw_page = tk.Frame(sign_in_notebook)\n        sign_in_notebook.add(forgot_pw_page, text='Forgot Password?')\n\n        main_frame = tk.Frame(forgot_pw_page, relief=tk.FLAT)\n        main_frame.pack(fill=tk.BOTH, side=tk.TOP)\n\n        main_label = tk.Label(main_frame, text='Library System v1.0')\n        main_label.pack(fill=tk.X, anchor=tk.N)\n\n        header_frame = tk.Frame(forgot_pw_page)\n        header_frame.pack(fill=tk.X, side=tk.TOP)\n\n        header = tk.Label(header_frame, text='Forgot Password?', font='System 30')\n        header.pack(side=tk.TOP)\n\n        #Credentials Container\n        credentials_container = tk.Frame(forgot_pw_page, bg=bg)\n        credentials_container.pack(padx=padx, pady=pady)\n\n        #Email Container\n        email_container = tk.Frame(credentials_container, bg=bg)\n        email_container.pack(expand=True)\n\n        email_label = tk.Label(email_container, text='    Email:   ', bg=bg)\n        email_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.user_email_var = tk.StringVar()\n        self.user_email_var.set('')\n        self.email_entry = ttk.Entry(email_container, textvariable=self.user_email_var,\n                                                font='System 6')\n        self.email_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        #Send Request Button Container\n        button_container = tk.Frame(credentials_container, bg=bg)\n        button_container.pack(expand=True)\n\n        send_request_button = ttk.Button(button_container, text='Send Request', command=lambda:self.send_request())\n        exit_button = ttk.Button(button_container, text='Exit', command=lambda:self.system_exit())\n\n        send_request_button.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n        exit_button.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        self.email_entry.bind(\"<Return>\", self.send_request)\n\n    def send_request(self, *args):\n        #Accepted email standard internarionally.\n        input_email = self.user_email_var.get()\n        email_regex = '^[a-z0-9]+[\\._]?[a-z0-9]+[@]\\w+[.]\\w{2,3}$'\n        #Check if the email address exists in the database\n        email_address_fetch = c.execute(\"SELECT email_address FROM Accounts WHERE email_address=?\",(self.user_email_var.get(),))\n        email_address_list = email_address_fetch.fetchall()\n\n        if len(email_address_list)==0:\n            ms.showerror('Error','This account does not exist in our system.')\n        elif (re.search(email_regex, input_email)):\n            #Open TopLevel Window so the user can enter the emailed password, then the new password they want\n            #1. TopLevel window and layout.\n            self.forgotPassword = tk.Toplevel()\n\n            #configurations\n            self.forgotPassword.title(\"Account Verification\")\n            self.forgotPassword.option_add('*Font', 'System 12')\n            self.forgotPassword.option_add('*Label.Font', 'System 12')\n            self.forgotPassword.geometry('500x500')\n            self.forgotPassword.resizable(False, False)\n\n\n            main_frame = tk.Frame(self.forgotPassword, relief=tk.FLAT)\n            main_frame.pack(fill=tk.BOTH, side=tk.TOP)\n\n            main_label = tk.Label(main_frame, text='Library System v1.0')\n            main_label.pack(fill=tk.X, anchor=tk.N)\n\n            header_frame = tk.Frame(self.forgotPassword)\n            header_frame.pack(fill=tk.X, side=tk.TOP)\n\n            header = tk.Label(header_frame, text='Forgot Password', font='System 30')\n            header.pack(side=tk.TOP)\n\n            header_description = tk.Label(header_frame, text='A randomly generated password has been send to \\n'+input_email+'\\n Please enter the password into the \"Generated Password\" entry field below.', font='System 8')\n            header_description.pack(side=tk.TOP)\n\n            self.timer_text = tk.Label(header_frame, text='Time until another password can be resent.')\n            self.timer_text.pack(side=tk.TOP)\n\n            self.timer = tk.Label(header_frame, text='')\n            self.timer.pack(side=tk.TOP)\n\n            self.time_remaining = 0\n            self.countdown(60)\n\n\n            #Passwords Full Container\n            passwords_container = tk.Frame(self.forgotPassword, bg=bg)\n            passwords_container.pack(padx=padx, pady=pady)\n\n            #Generated Password Entry Field Container\n            generated_password_container = tk.Frame(passwords_container, bg=bg)\n            generated_password_container.pack(expand=True)\n\n            generated_password_label = tk.Label(generated_password_container, text='    Generated Password:   ', bg=bg)\n            generated_password_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n\n            self.generated_password_var = tk.StringVar()\n            self.generated_password_var.set('')\n            self.generated_password_entry = ttk.Entry(generated_password_container, textvariable=self.generated_password_var,font='System 6')\n            self.generated_password_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n            #Password Container\n            new_password_container = tk.Frame(passwords_container, bg=bg)\n            new_password_container.pack(expand=True)\n\n            new_password_label = tk.Label(new_password_container, text=' New Password:', bg=bg)\n            new_password_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n            self.new_password_var = tk.StringVar()\n            self.new_password_var.set('')\n            self.new_password_var.trace(\"w\", self.password_strength)\n\n            self.new_password_entry = ttk.Entry(new_password_container, textvariable=self.new_password_var,\n                                                    font='System 6', show='*')\n            self.new_password_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n            #Confirm Password Container\n            confirm_pw_container = tk.Frame(passwords_container, bg=bg)\n            confirm_pw_container.pack(expand=True)\n\n            confirm_pw_label = tk.Label(confirm_pw_container, text='Confirm\\n New Password:', bg=bg)\n            confirm_pw_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n            self.confirm_pw_var = tk.StringVar()\n            self.confirm_pw_var.set('')\n            self.confirm_pw_entry = ttk.Entry(confirm_pw_container, textvariable=self.confirm_pw_var,\n                                                    font='System 6', show='*')\n            self.confirm_pw_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n            #Password Strength measure container\n            self.password_strength_container_1 = tk.Frame(passwords_container, bg=bg)\n            self.password_strength_container_1.pack(expand=True)\n\n            self.password_strength_label_1 = tk.Label(self.password_strength_container_1, text='Password must be a minimum of 8 characters.',\n                                                    bg=bg, fg='orange red')\n            self.password_strength_label_1.pack(anchor=tk.E, side=tk.RIGHT, padx=padx, pady=pady)\n\n\n            self.password_strength_container_2 = tk.Frame(passwords_container, bg=bg)\n            self.password_strength_container_2.pack(expand=True)\n\n            self.password_strength_label_2 = tk.Label(self.password_strength_container_2, text=\"\"\"Besides letters, include at least a number or symbol shown below \\n)([!@#$%^*-_+=|\\\\\\{\\}\\[\\]`¬;:@\"'<>,./?]\"\"\",\n                                                    bg=bg, fg='orange red')\n            self.password_strength_label_2.pack(anchor=tk.E, side=tk.RIGHT, padx=padx, pady=pady)\n\n\n            #Buttons Container\n            button_container = tk.Frame(passwords_container, bg=bg)\n            button_container.pack(expand=True)\n\n            update_password_button = ttk.Button(button_container, text='Update Password', command=lambda:self.update_password())\n            show_password_button = ttk.Button(button_container, text='Show Password', command=lambda:self.show_password())\n            resend_password_button = ttk.Button(button_container, text='Resend Password', command=lambda:self.resend_password())\n\n            update_password_button.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n            show_password_button.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n            resend_password_button.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n            self.generated_password_entry.bind(\"<Return>\", self.update_password)\n\n            #Randomly generate a password\n            charset=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()\"\n            self.gen_random_password = ''.join([secrets.choice(charset) for _ in range(0, 10)])\n\n            #Send the password to the email constructor.\n            e = Email()\n            service = e.get_service()\n            message = e.create_forgot_password_message(\"from@gmail.com\",input_email,\"Books4All Forgot Password?\", self.gen_random_password)\n            e.send_message(service,\"from@gmail.com\",message)\n\n        else:\n            ms.showerror('Error','Invalid email address')\n\n    def update_password(self):\n        if self.gen_random_password == self.generated_password_var.get().strip():  \n            if self.new_password_var.get() != self.confirm_pw_var.get():\n                ms.showwarning('Warning','Your passwords do not match.')\n            elif self.new_password_var.get() == '' or self.confirm_pw_var.get() == '':\n                ms.showwarning('Warning', 'You left the password fields empty!')\n            else:\n                #Update the password in the database to this.\n                #Encrypt+Salt New PW\n                hashable_new_pw = bytes(self.new_password_var.get(), 'utf-8')\n                hashed_new_pw = bcrypt.hashpw(hashable_new_pw, bcrypt.gensalt())\n\n                #Convert into base64string\n                db_hashed_pw = hashed_new_pw.decode(\"utf-8\")\n\n                db_new_pw_update = c.execute('UPDATE Accounts SET password=? WHERE email_address=?',(db_hashed_pw, self.user_email_var.get()))\n                conn.commit()\n\n                ms.showinfo('Success','Your password has been updated!')\n                self.forgotPassword.destroy()\n\n                #Switch tabs after registration\n                login_index = self.sign_in_notebook.index(0)\n                self.sign_in_notebook.select(login_index)\n\n        else:\n            ms.showerror('Error','The password that was sent did not match the password you entered.')\n\n\n    def resend_password(self):\n        if self.timer[\"text\"] == \"Ready to Resend Password!\":\n            #Randomly generate a password\n            charset=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()\"\n            self.gen_random_password = ''.join([secrets.choice(charset) for _ in range(0, 10)])\n\n            #Send the password to the email constructor.\n            e = Email()\n            service = e.get_service()\n            message = e.create_forgot_password_message(\"from@gmail.com\",self.user_email_var.get(),\"Books4All Forgot Password?\", self.gen_random_password)\n            e.send_message(service,\"from@gmail.com\",message)\n            ms.showinfo('Success','A new randomly generated password has been sent to the email address.')\n\n            self.time_remaining = 0\n            self.countdown(60)\n        else:\n            ms.showwarning('Warning','Please wait another '+self.timer[\"text\"]+'seconds to resend a password.')\n\n    def password_strength(self, *args):\n        special_characters_regex = re.compile(\"\"\"[!@#$%^*-_+=|\\\\\\{\\}\\[\\]`¬;:@\"'<>,./?]()\"\"\")\n        password_input = self.new_password_var.get()\n\n        if len(password_input) >= 8:\n            self.password_strength_container_1.pack_forget()\n            if special_characters_regex.search(password_input) != None :\n                self.password_strength_container_2.pack_forget()\n            else:\n                self.password_strength_container_2.pack(expand=True)\n\n        elif len(password_input) < 8:\n            self.password_strength_container_1.pack(expand=True)\n            if special_characters_regex.search(password_input) != None :\n                self.password_strength_container_2.pack_forget()\n            else:\n                self.password_strength_container_2.pack(expand=True)\n\n    def show_password(self, *args):\n        if self.new_password_entry[\"show\"] == \"*\":\n            self.new_password_entry[\"show\"]=''\n            self.confirm_pw_entry[\"show\"]=''\n        else:\n            self.new_password_entry[\"show\"]='*'\n            self.confirm_pw_entry[\"show\"]='*'\n\n    def countdown(self, time_remaining = None):\n        if time_remaining is not None:\n            self.time_remaining = time_remaining\n\n        if self.time_remaining <= 0:\n            self.timer[\"text\"]=\"Ready to Resend Password!\"\n        else:\n            self.timer[\"text\"]=(\"%d\" % self.time_remaining)\n            self.time_remaining = self.time_remaining - 1\n            self.forgotPassword.after(1000, self.countdown)\n\n    def system_exit(self):\n        root.destroy()\n        sys.exit()\n\nclass Register():\n    def __init__(self, parent, sign_in_notebook):\n        register_page = tk.Frame(sign_in_notebook)\n        self.sign_in_notebook = sign_in_notebook\n        self.sign_in_notebook.add(register_page, text='Register')\n\n        main_frame = tk.Frame(register_page, relief=tk.FLAT)\n        main_frame.pack(fill=tk.BOTH, side=tk.TOP)\n\n        main_label = tk.Label(main_frame, text='Library System v1.0')\n        main_label.pack(fill=tk.X, anchor=tk.N)\n\n        header_frame = tk.Frame(register_page)\n        header_frame.pack(fill=tk.X, side=tk.TOP)\n\n        header = tk.Label(header_frame, text='Register', font='System 30')\n        header.pack(side=tk.TOP)\n\n        #Register Container\n        register_container = tk.Frame(register_page, bg=bg)\n        register_container.pack(padx=padx, pady=pady)\n\n        #Email Container\n        email_container = tk.Frame(register_container, bg=bg)\n        email_container.pack(expand=True)\n\n        email_label = tk.Label(email_container, text='    Email:   ', bg=bg)\n        email_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.user_email_var = tk.StringVar()\n        self.user_email_var.set('')\n        self.email_entry = ttk.Entry(email_container, textvariable=self.user_email_var,\n                                                font='System 6')\n        self.email_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        #Password Container\n        password_container = tk.Frame(register_container, bg=bg)\n        password_container.pack(expand=True)\n\n        password_label = tk.Label(password_container, text=' Password:', bg=bg)\n        password_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.user_password_var = tk.StringVar()\n        self.user_password_var.set('')\n        self.user_password_var.trace(\"w\", self.password_strength)\n\n        self.password_entry = ttk.Entry(password_container, textvariable=self.user_password_var,\n                                                font='System 6', show='*')\n        self.password_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n\n\n        #Confirm Password Container\n        confirm_pw_container = tk.Frame(register_container, bg=bg)\n        confirm_pw_container.pack(expand=True)\n\n        confirm_pw_label = tk.Label(confirm_pw_container, text='Confirm\\n Password:', bg=bg)\n        confirm_pw_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.confirm_pw_var = tk.StringVar()\n        self.confirm_pw_var.set('')\n        self.confirm_pw_entry = ttk.Entry(confirm_pw_container, textvariable=self.confirm_pw_var,\n                                                font='System 6', show='*')\n        self.confirm_pw_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        #Register Button Container\n        button_container = tk.Frame(register_container, bg=bg)\n        button_container.pack(expand=True)\n\n        register_button = ttk.Button(button_container, text='Register', command=lambda:self.register())\n        exit_button = ttk.Button(button_container, text='Exit', command=lambda:self.system_exit())\n        show_password_button = ttk.Button(button_container, text='Show Password', command=lambda:self.show_password())\n\n        register_button.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n        exit_button.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n        show_password_button.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        self.email_entry.bind(\"<Return>\", self.register)\n        self.password_entry.bind(\"<Return>\", self.register)\n        self.confirm_pw_entry.bind(\"<Return>\", self.register)\n\n        #Password Strength measure container\n        self.password_strength_container_1 = tk.Frame(register_container, bg=bg)\n        self.password_strength_container_1.pack(expand=True)\n\n        self.password_strength_label_1 = tk.Label(self.password_strength_container_1, text='Password must be a minimum of 8 characters.',\n                                                bg=bg, fg='orange red')\n        self.password_strength_label_1.pack(anchor=tk.E, side=tk.RIGHT, padx=padx, pady=pady)\n\n\n        self.password_strength_container_2 = tk.Frame(register_container, bg=bg)\n        self.password_strength_container_2.pack(expand=True)\n\n        self.password_strength_label_2 = tk.Label(self.password_strength_container_2, text=\"\"\"Besides letters, include at least a number or symbol )([!@#$%^*-_+=|\\\\\\{\\}\\[\\]`¬;:@\"'<>,./?]\"\"\",\n                                                bg=bg, fg='orange red')\n        self.password_strength_label_2.pack(anchor=tk.E, side=tk.RIGHT, padx=padx, pady=pady)\n\n    def register(self, *args):\n        # delete if statement and replace with database check for user's input credentials\n        #validity checks for entry field + logic\n        self.reg_email = self.user_email_var.get()\n\n        #Accepted email standard internarionally.\n        email_regex = '^[a-z0-9]+[\\._]?[a-z0-9]+[@]\\w+[.]\\w{2,3}$'\n\n        if (re.search(email_regex, self.reg_email)):\n            reg_pw = self.user_password_var.get()\n            reg_confirm_pw = self.confirm_pw_var.get()\n\n            if reg_pw != reg_confirm_pw:\n                ms.showwarning('Warning','Your passwords do not match.')\n            elif reg_pw == '' or reg_pw == '':\n                ms.showwarning('Warning', 'You left the password fields empty!')\n            else:\n                #Encrypt+Salt PWs\n                hashable_pw = bytes(reg_pw, 'utf-8')\n                hashed_pw = bcrypt.hashpw(hashable_pw, bcrypt.gensalt())\n\n                #Convert into base64string\n                self.db_hashed_pw = hashed_pw.decode(\"utf-8\")\n\n                #Send password to DB\n                with sqlite3.connect('LibrarySystem.db') as db:\n                    c = db.cursor()\n\n                find_user = ('SELECT * FROM Accounts WHERE email_address = ?')\n                c.execute(find_user,[(self.reg_email)])\n\n                if c.fetchall():\n                    ms.showerror('Error!','Email is already registered to an Account.')\n                else:\n                    #Will need to verify whether this email address is linked to the user.\n                    #Steps to take in the following code:\n                    # 1. Open a TopLevel window to prompt the user to enter a code into an entry box /DONE\n                    # 2. Send the user an email with a randomly generated 6 digit code\n                    # 3. Compare the 6 digit code the user entered to the one that was sent.\n                    # 4. If they match, close the TopLevel, and follow on with the rest of the code below.\n                    # 5. If the codes do not match, then an error will be prompted.\n                    # 6. A 'Resend Code' button will be available on a cooldown (1min to stop spammers) that sends another code to the user.\n                    #    Upon this code being sent, the previous code needs to be made invalid.\n\n                    #1. TopLevel window and layout.\n                    self.accountVerification = tk.Toplevel()\n\n                    #configurations\n                    self.accountVerification.title(\"Account Verification\")\n                    self.accountVerification.option_add('*Font', 'System 12')\n                    self.accountVerification.option_add('*Label.Font', 'System 12')\n                    self.accountVerification.geometry('500x500')\n                    self.accountVerification.resizable(False, False)\n\n\n                    main_frame = tk.Frame(self.accountVerification, relief=tk.FLAT)\n                    main_frame.pack(fill=tk.BOTH, side=tk.TOP)\n\n                    main_label = tk.Label(main_frame, text='Library System v1.0')\n                    main_label.pack(fill=tk.X, anchor=tk.N)\n\n                    header_frame = tk.Frame(self.accountVerification)\n                    header_frame.pack(fill=tk.X, side=tk.TOP)\n\n                    header = tk.Label(header_frame, text='Account Verification', font='System 30')\n                    header.pack(side=tk.TOP)\n\n                    header_description = tk.Label(header_frame, text='A 6 digit verification code has been sent to\\n'+self.reg_email+'\\n Please enter the 6 digit code into the entry field below.', font='System 8')\n                    header_description.pack(side=tk.TOP)\n\n                    self.timer = tk.Label(header_frame, text='')\n                    self.timer.pack(side=tk.TOP)\n\n                    self.time_remaining = 0\n                    self.countdown(60)\n\n                    #Codes Full Container\n                    code_container = tk.Frame(self.accountVerification, bg=bg)\n                    code_container.pack(padx=padx, pady=pady)\n\n                    #Code Entry Field Container\n                    verification_code_container = tk.Frame(code_container, bg=bg)\n                    verification_code_container.pack(expand=True)\n\n                    verification_code_label = tk.Label(verification_code_container, text='    Verification Code:   ', bg=bg)\n                    verification_code_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n                    self.verification_code_reg = root.register(self.verification_code_validate)\n\n                    self.verification_code_var = tk.StringVar()\n                    self.verification_code_var.set('')\n                    self.verification_code_entry = ttk.Entry(verification_code_container, textvariable=self.verification_code_var,\n                                                            font='System 6', validate=\"key\",\n                                                            validatecommand=(self.verification_code_reg, \"%P\"))\n                    self.verification_code_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n                    #Buttons Container\n                    button_container = tk.Frame(code_container, bg=bg)\n                    button_container.pack(expand=True)\n\n                    check_code_button = ttk.Button(button_container, text='Check Verification Code', command=lambda:self.check_code(self.verification_code_var.get()))\n                    resend_code_button = ttk.Button(button_container, text='Resend Verification Code', command=lambda:self.resend_code(self.verification_code_var.get()))\n\n                    check_code_button.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n                    resend_code_button.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n                    \n\n                    self.verification_code_entry.bind(\"<Return>\", self.check_code)\n\n\n                    #2.1. Randomly generate a 6 digit code to be sent by email\n                    self.email_verification_code = ''\n                    i=0\n                    while i<6:\n                        random_integer = random.SystemRandom().randint(0,9)\n                        i+=1\n                        self.email_verification_code += str(random_integer)\n\n\n                    #2.2. Send Email to user with the verification code.\n                    #Call the Email class\n                    e = Email()\n                    service = e.get_service()\n                    message = e.create_verification_message(\"from@gmail.com\",self.reg_email,\"Books4All Verification Code\", self.email_verification_code)\n                    e.send_message(service,\"from@gmail.com\",message)\n\n        else:\n            ms.showerror('Error', 'Invalid Email Address')\n\n    def check_code(self, *args):\n        #3. Compare the email code with the input code\n        if self.verification_code_var.get() != self.email_verification_code:\n            ms.showerror('Error','The verification code does not match the code sent.')\n        else:\n            ms.showinfo('Success','The verification code matches the code we sent!')\n            self.accountVerification.destroy()\n\n            with sqlite3.connect('LibrarySystem.db') as db:\n                    c = db.cursor()\n            #IF YOU DELETED THE DB, COMMENT THE 2 LINES BELOW, AND COPY THIS PART BELOW IT\n            # insert = 'INSERT INTO Accounts(email_address,password,my_booksID,staff_mode,admin_mode) VALUES(?,?,?,?,?)'\n            # c.execute(insert,[(self.reg_email),(self.db_hashed_pw),(\"1\"),(\"1\"),(\"1\")])\n            # db.commit()\n\n            select_highest_val = c.execute('SELECT MAX(my_booksID) + 1 FROM Accounts').fetchall()\n            highest_val = [x[0] for x in select_highest_val][0]\n\n            insert = 'INSERT INTO Accounts(email_address,password,my_booksID) VALUES(?,?,?)'\n            c.execute(insert,[(self.reg_email),(self.db_hashed_pw),(highest_val)])\n            db.commit()\n\n            ms.showinfo('Success!','Account Created!')\n\n            #Switch tabs after registration\n            login_index = self.sign_in_notebook.index(0)\n            self.sign_in_notebook.select(login_index)\n\n            #Remove details from register entry fields\n            self.user_email_var.set('')\n            self.user_password_var.set('')\n            self.confirm_pw_var.set('')\n\n\n    def resend_code(self, *args):\n        if self.timer[\"text\"] == \"Ready to Resend Code!\":\n            self.email_verification_code = ''\n            i=0\n            while i<6:\n                random_integer = random.SystemRandom().randint(0,9)\n                i+=1\n                self.email_verification_code += str(random_integer)\n\n            #2.2. Send Email to user with the verification code.\n            #Call the Email class\n            e = Email()\n            service = e.get_service()\n            message = e.create_verification_message(\"from@gmail.com\", self.reg_email, \"Books4All Verification Code\", self.email_verification_code)\n            e.send_message(service, \"from@gmail.com\", message)\n\n            self.time_remaining = 0\n            self.countdown(60)\n        else:\n            ms.showwarning('Warning','Please wait another '+self.timer[\"text\"]+'seconds to resend a code.')\n\n    def countdown(self, time_remaining = None):\n        if time_remaining is not None:\n            self.time_remaining = time_remaining\n\n        if self.time_remaining <= 0:\n            self.timer[\"text\"]=\"Ready to Resend Code!\"\n        else:\n            self.timer[\"text\"]=(\"%d\" % self.time_remaining)\n            self.time_remaining = self.time_remaining - 1\n            self.accountVerification.after(1000, self.countdown)\n        \n    def verification_code_validate(self, verification_code_inp):\n        if verification_code_inp.isdigit():\n            if len(verification_code_inp) > 6:\n                return False\n            else:\n                return True\n        elif verification_code_inp is \"\":\n            return True\n        else:\n            return False\n\n    def password_strength(self, *args):\n        special_characters_regex = re.compile(\"\"\"[!@#$%^*-_+=|\\\\\\{\\}\\[\\]`¬;:@\"'<>,./?]()\"\"\")\n        password_input = self.user_password_var.get()\n\n        if len(password_input) >= 8:\n            self.password_strength_container_1.pack_forget()\n            if special_characters_regex.search(password_input) != None :\n                self.password_strength_container_2.pack_forget()\n            else:\n                self.password_strength_container_2.pack(expand=True)\n\n        elif len(password_input) < 8:\n            self.password_strength_container_1.pack(expand=True)\n            if special_characters_regex.search(password_input) != None :\n                self.password_strength_container_2.pack_forget()\n            else:\n                self.password_strength_container_2.pack(expand=True)\n\n    def show_password(self, *args):\n        if self.password_entry[\"show\"] == \"*\":\n            self.password_entry[\"show\"]=''\n            self.confirm_pw_entry[\"show\"]=''\n        else:\n            self.password_entry[\"show\"]='*'\n            self.confirm_pw_entry[\"show\"]='*'\n\n\n    def system_exit(self):\n        root.destroy()\n        sys.exit()\n\n\nclass Email():\n    def __init__(self):\n        logging.basicConfig(\n                        format=\"[%(levelname)s] %(message)s\",\n                        level=logging.INFO\n                    )\n    @staticmethod\n    def get_service():\n        \"\"\"Gets an authorized Gmail API service instance.\n\n        Returns:\n            An authorized Gmail API service instance..\n        \"\"\"    \n\n        # If modifying these scopes, delete the file token.pickle.\n        SCOPES = [\n            'https://www.googleapis.com/auth/gmail.readonly',\n            'https://www.googleapis.com/auth/gmail.send',\n        ]\n\n        creds = None\n        # The file token.pickle stores the user's access and refresh tokens, and is\n        # created automatically when the authorization flow completes for the first\n        # time.\n        logging.getLogger('googleapiclient.discovery_cache').setLevel(logging.ERROR)\n        if os.path.exists('token.pickle'):\n            with open('token.pickle', 'rb') as token:\n                creds = pickle.load(token)\n        # If there are no (valid) credentials available, let the user log in.\n        if not creds or not creds.valid:\n            if creds and creds.expired and creds.refresh_token:\n                creds.refresh(Request())\n            else:\n                flow = InstalledAppFlow.from_client_secrets_file(\n                    'credentials.json', SCOPES)\n                creds = flow.run_local_server(port=0)\n            # Save the credentials for the next run\n            with open('token.pickle', 'wb') as token:\n                pickle.dump(creds, token)\n\n        service = build('gmail', 'v1', credentials=creds)\n        return service\n\n    @staticmethod\n    def send_message(service, sender, message):\n        try:\n            sent_message = (service.users().messages().send(userId='me', body=message)\n                .execute())\n            logging.info('Message Id: %s', sent_message['id'])\n            return sent_message\n        except errors.HttpError as error:\n            logging.error('An HTTP error occurred: %s', error)\n\n    @staticmethod\n    def create_verification_message(sender, to, subject, verification_code):\n        \"\"\"Create a verification message.\n\n        Returns:\n          An object containing a base64url encoded email object.\n        \"\"\"\n        html = open(\"verification_email.html\")\n\n        soup = BeautifulSoup(html, features=\"lxml\")\n        html.close()\n        target = soup.find(id='verification_code')\n        target_result = soup.find(id='verification_code').find_all(text=True, recursive=False)\n        target_text = str(target_result[0])\n\n        for v in target:\n            v.replace_with(v.replace(target_text,verification_code))\n\n        with open(\"verification_email.html\", \"w\") as file:\n            file.write(str(soup))\n\n        updated_html = open(\"verification_email.html\")\n\n        message = MIMEText(updated_html.read(), 'html')\n\n\n\n        message['to'] = to\n        message['from'] = sender\n        message['subject'] = subject\n        s = message.as_string()\n        b = base64.urlsafe_b64encode(s.encode('utf-8'))\n        return {'raw': b.decode('utf-8')}\n\n    @staticmethod\n    def create_forgot_password_message(sender, to, subject, gen_random_password):\n        \"\"\"Create a forgot password message for an email.\n        Returns:\n          An object containing a base64url encoded email object.\n        \"\"\"\n        html = open(\"forgot_password_email.html\")\n\n        soup = BeautifulSoup(html, features=\"lxml\")\n        html.close()\n        target = soup.find(id='random_password')\n        target_result = soup.find(id='random_password').find_all(text=True, recursive=False)\n        target_text = str(target_result[0])\n\n        for v in target:\n            v.replace_with(v.replace(target_text,gen_random_password))\n\n        with open(\"forgot_password_email.html\", \"w\") as file:\n            file.write(str(soup))\n\n        updated_html = open(\"forgot_password_email.html\")\n\n        message = MIMEText(updated_html.read(), 'html')\n\n        message['to'] = to\n        message['from'] = sender\n        message['subject'] = subject\n        s = message.as_string()\n        b = base64.urlsafe_b64encode(s.encode('utf-8'))\n        return {'raw': b.decode('utf-8')}\n\nclass Login():\n    def __init__(self, parent, sign_in_notebook):\n        self.parent = parent\n        login_page = tk.Frame(sign_in_notebook)\n        sign_in_notebook.add(login_page, text='Login')\n\n        main_frame = tk.Frame(login_page, relief=tk.FLAT)\n        main_frame.pack(fill=tk.BOTH, side=tk.TOP)\n\n        main_label = tk.Label(main_frame, text='Library System v1.0')\n        main_label.pack(fill=tk.X, anchor=tk.N)\n\n        header_frame = tk.Frame(login_page)\n        header_frame.pack(fill=tk.X, side=tk.TOP)\n\n        header = tk.Label(header_frame, text='Login', font='System 30')\n        header.pack(side=tk.TOP)\n\n        #Login Container\n        login_container = tk.Frame(login_page, bg=bg)\n        login_container.pack(padx=padx, pady=pady)\n\n        #Email Container\n        email_container = tk.Frame(login_container, bg=bg)\n        email_container.pack(expand=True)\n\n        email_label = tk.Label(email_container, text='    Email:   ', bg=bg)\n        email_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.user_email_var = tk.StringVar()\n        self.user_email_var.set('')\n        self.email_entry = ttk.Entry(email_container, textvariable=self.user_email_var, font='System 6',)\n        self.email_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n        self.email_entry.focus()\n\n\n        #Password Container\n        password_container = tk.Frame(login_container, bg=bg)\n        password_container.pack(expand=True)\n\n        password_label = tk.Label(password_container, text=' Password:', bg=bg)\n        password_label.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n\n        self.user_password_var = tk.StringVar()\n        self.user_password_var.set('')\n        self.password_entry = ttk.Entry(password_container, textvariable=self.user_password_var,\n                                                font='System 6', show='*')\n        self.password_entry.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        #Login Button Container\n        button_container = tk.Frame(login_container, bg=bg)\n        button_container.pack(expand=True)\n\n        login_button = ttk.Button(button_container, text='Login', command=lambda:self.login())\n        exit_button = ttk.Button(button_container, text='Exit', command=lambda:self.system_exit())\n\n        login_button.pack(side=tk.LEFT, anchor=tk.W, padx=padx, pady=pady)\n        exit_button.pack(side=tk.RIGHT, anchor=tk.E, padx=padx, pady=pady)\n\n        self.email_entry.bind(\"<Return>\", self.login)\n        self.password_entry.bind(\"<Return>\", self.login)\n\n    def login(self, *args):\n        login_email = self.user_email_var.get()\n        login_password = self.user_password_var.get()\n\n        # CHECK DETAILS AGAINST DATABASE DETAILS\n        if login_password == '' and login_email  == '':\n             ms.showwarning('Warning','Enter your email address and password')\n        else:\n\n            pass_hashed_fetch = c.execute('SELECT password FROM Accounts WHERE email_address = ?', (login_email,))\n            pass_hashed = c.fetchone()[0]\n\n            pass_hashed_encode = pass_hashed.encode('utf-8')\n\n            bytes_login_password = bytes(login_password, 'utf-8')\n            \n\n            if bcrypt.checkpw(bytes_login_password, pass_hashed_encode):\n                ms.showinfo('Success', 'Successfully Logged in!')\n                for child in self.parent.winfo_children():\n                    child.destroy()\n\n                MainApplication(self.parent, login_email)\n\n                self.user_email_var.set('')\n                self.user_password_var.set('')\n            else:\n                ms.showerror('Error','Incorrect password/email')\n\n\n    def system_exit(self):\n        root.destroy()\n        sys.exit()\n\n\nclass SignIn():\n    def __init__(self, parent):\n        self.parent = parent\n        sign_in_notebook = ttk.Notebook(self.parent)\n        sign_in_notebook.pack(expand=True, fill=tk.BOTH)\n\n        login = Login(parent, sign_in_notebook)\n        register = Register(parent, sign_in_notebook)\n        forgot_pw = ForgotPW(parent, sign_in_notebook)\n\n        \n\nclass MainApplication():\n    def __init__(self, parent, email):\n        # Declare variables\n        self.parent = parent\n        self.email = email\n\n\n        parent.configure(bg='gray15')\n        parent.title(\"Library System v1.0\")\n        parent.option_add('*Font', 'System 12')\n        parent.option_add('*Label.Font', 'System 12')\n        parent.geometry(geometry)\n\n\n        #Global Header\n        global_frame = tk.Frame(parent, relief=tk.FLAT)\n        global_frame.pack(fill=tk.BOTH, side=tk.TOP)\n\n        global_label = tk.Label(global_frame, text='Library System v1.0')\n        global_label.pack(fill=tk.X, anchor=tk.N)\n\n        #Logout button\n        logout_button = ttk.Button(global_frame, text='Logout', command=self.logout)\n        logout_button.pack(side=tk.RIGHT)\n\n\n        self.main_notebook = ttk.Notebook(parent)\n        self.main_notebook.pack(expand=True, fill=tk.BOTH)\n\n\n        #Instantiate Classes (HP = Home Page, MBP = My Books Page, etc...)\n        self.HP = Home(self.parent, self.main_notebook)\n        self.AP = Account(self.parent, self.main_notebook, self.email)\n        self.MBP = MyBooks(self.parent, self.main_notebook, self.email)\n        self.LP = Library(self.parent, self.main_notebook)\n\n        # Needs 'Staff' powers to see this page, put behind an if statement.\n        #check if the user has staff privileges\n        staff_mode_check = c.execute('SELECT staff_mode FROM Accounts WHERE email_address=?',(email,)).fetchall()\n        staff_mode = [x[0] for x in staff_mode_check][0]\n\n        if staff_mode == 1:\n            self.BDP = BookDatabase(self.parent, self.main_notebook, self.email)\n\n        admin_mode_check = c.execute('SELECT admin_mode FROM Accounts WHERE email_address=?',(email,)).fetchall()\n        admin_mode = [x[0] for x in staff_mode_check][0]\n\n        if admin_mode == 1:\n            self.AP = Admin(self.parent, self.main_notebook, self.email)\n\n        self.OP = Options(self.parent, self.main_notebook)\n\n    def logout(self):\n        logout_confirmation = ms.askquestion('Logout', 'Are you sure you want to logout?', icon='warning')\n        if logout_confirmation == 'yes':\n            for child in self.parent.winfo_children():\n                child.destroy()\n            SignIn(self.parent)\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n    root = tk.Tk()\n\n    rlp = SignIn(root)\n\n    root.mainloop()\n",
			"file": "main.py",
			"file_size": 185983,
			"file_write_time": 132493289814982629,
			"settings":
			{
				"buffer_size": 181721,
				"line_ending": "Windows",
				"name": "#"
			}
		},
		{
			"file": "create_db.py",
			"settings":
			{
				"buffer_size": 1258,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/Python/Python.sublime-build",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					"Syntax Check"
				]
			],
			[
				"Packages/Python/Python.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"Package ResourceViewer",
				"PackageResourceViewer: Open Resource"
			],
			[
				"Packalge Control: Install Package",
				"Package Control: Install Package"
			],
			[
				"Install Package Control",
				"Package Control: Install Package"
			],
			[
				"prv",
				"Permute Lines: Reverse"
			],
			[
				"python",
				"Build With: Python"
			],
			[
				"Install",
				"Package Control: Install Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/C/Users/marco/Desktop/Collyer's Folder/Computer Science/Y2 Project/Library Management System/create_db.py",
		"/C/Users/marco/Desktop/Collyer's Folder/Computer Science/Y2 Project/Library Management System/insert_book_values.py",
		"/C/Users/marco/Desktop/Programming/MERCEDESBENZ.py",
		"/C/Users/marco/Desktop/Programming/Mandelbrot fractaql/fractal.py",
		"/C/Users/marco/Desktop/Collyer's Folder/Computer Science/Y2 Project/Library Management System/test.py",
		"/C/Users/marco/Desktop/Collyer's Folder/Computer Science/Y2 Project/Library Management System/modes.py",
		"/C/Users/marco/Desktop/Collyer's Folder/Computer Science/Y2 Project/Library Management System/testing different modes.py",
		"/C/Users/marco/Desktop/Collyer's Folder/Computer Science/Y2 Project/Library Management System/join statement tests.py",
		"/C/Users/marco/Desktop/Collyer's Folder/Computer Science/Y2 Project/Library Management System/autocomplete.py",
		"/C/Users/marco/Desktop/Programming/TEST_DB.py",
		"/C/Users/marco/Desktop/Programming/hash issue db.py",
		"/C/Users/marco/AppData/Roaming/Sublime Text 3/Packages/Default/exec.py",
		"/C/Users/marco/Desktop/Collyer's Folder/Computer Science/Y2 Project/create_db.py",
		"/C/Users/marco/Desktop/Programming/Library Management System Flask/run.py",
		"/C/Users/marco/Desktop/Programming/Library Management System Flask/LMSf/users/utils.py",
		"/C/Users/marco/Desktop/Programming/Library Management System Flask/LMSf/users/routes.py",
		"/C/Users/marco/Desktop/Programming/Library Management System Flask/LMSf/users/forms.py",
		"/C/Users/marco/Desktop/Programming/Library Management System Flask/LMSf/posts/routes.py",
		"/C/Users/marco/Desktop/Programming/Library Management System Flask/LMSf/main/routes.py",
		"/C/Users/marco/Desktop/Programming/Library Management System Flask/LMSf/models.py",
		"/C/Users/marco/Desktop/Programming/Library Management System Flask/LMSf/__init__.py",
		"/C/Users/marco/Desktop/Programming/Library Management System Flask/LMSf/env/Scripts/Activate.ps1",
		"/C/Users/marco/Desktop/Programming/Library Management System Flask/LMSf/env/Scripts/activate.bat",
		"/C/Users/marco/Desktop/Programming/Library Management System Flask/LMSf/env/Scripts/activate",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/users/forms.py",
		"/C/Users/marco/Desktop/Programming/Flask/Procfile",
		"/C/Users/marco/Desktop/Programming/Flask/requirements.txt",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/__init__.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/templates/errors/500.html",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/templates/errors/403.html",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/templates/errors/404.html",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/errors/handlers.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/errors/__init__.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/models.py",
		"/C/Users/marco/Desktop/Programming/Flask/run.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/users/utils.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/config.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/templates/user_posts.html",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/templates/register.html",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/templates/post.html",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/templates/login.html",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/templates/layout.html",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/templates/home.html",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/users/routes.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/posts/routes.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/main/routes.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/env/Lib/site-packages/flask/helpers.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/env/Lib/site-packages/flask_login/utils.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/posts/forms.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/routes.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/forms.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/templates/account.html",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/templates/create_post.html",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/templates/reset_token.html",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/templates/reset_request.html",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/main/__init__.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/posts/__init__.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/users/__init__.py",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/reset_token.html",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial/static/posts.json",
		"/C/Users/marco/Desktop/Programming/Flask/static/main.css",
		"/C/Users/marco/Desktop/Programming/Flask/templates/layout.html",
		"/C/Users/marco/Desktop/Programming/Flask/templates/about.html",
		"/C/Users/marco/Desktop/Programming/Flask/templates/home.html",
		"/C/Users/marco/Desktop/Programming/Flask/forms.py",
		"/C/Users/marco/Desktop/Programming/Flask/templates/login.html",
		"/C/Users/marco/Desktop/Programming/Flask/templates/register.html",
		"/C/Users/marco/Desktop/Programming/Flask/flask_tutorial.py",
		"/C/Users/marco/Desktop/Programming/Flask/models.py",
		"/C/Users/marco/AppData/Local/Temp/kite_tutorial.py",
		"/C/Users/marco/AppData/Roaming/Sublime Text 3/Packages/User/python3.sublime-build",
		"/C/Users/marco/AppData/Roaming/Sublime Text 3/Packages/KiteSublime/KiteSublime.sublime-settings",
		"/C/Users/marco/Desktop/Programming/Flask/flask tutorial.sublime-project",
		"/C/Users/marco/Desktop/Programming/Graveyard/emailsdcz",
		"/C/Users/marco/Desktop/Collyer's Folder/Computer Science/Transfer Project/testers/eTicket email Receipt Invoices Tests/Invoice Testing.py"
	],
	"find":
	{
		"height": 22.0
	},
	"find_in_files":
	{
		"height": 619.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"AutoCompleteEntryBD_ReturnBookID",
			"quickSort",
			"query_issued",
			"search_issued_tv_BD",
			"db_search_issued_var",
			"query_issued",
			"sort_upon_press",
			"genre",
			"search_issued_tv_BD",
			"_columns_searcher_genre_BD",
			"location_choice_list",
			"location",
			"location_choice_list",
			"location",
			"location_choice_list",
			"location",
			"Issued(",
			"Issued",
			"Issued 1/0",
			"Issue 1/0",
			"%Y-%m-%d",
			"%d-%m-%Y",
			"%d",
			"issue",
			"date",
			"issue_date",
			"print",
			"delete_account",
			"print",
			"sort_upon_press",
			"print",
			"sort_upon_press",
			"quickSort",
			"arr",
			"quickSort",
			"delete_account",
			"quickSort",
			"_values",
			"quickSort",
			"firstRun",
			"quickSort",
			"reverse",
			"quickSort",
			"arr",
			"quickSort",
			"arr",
			"quickSort",
			"Treeview",
			"date_issued_list",
			"i",
			"date_issued_list",
			"print",
			"issue_book",
			"genre",
			"_columns_searcher_genre",
			"genre",
			"_columns_searcher_genre",
			"genre",
			"Genre",
			"genre",
			"Genre",
			"genre",
			"Genre",
			"genre",
			"genre_menu",
			"value",
			"genre",
			"Genre",
			"genre",
			"Genre",
			"genre",
			"Library()",
			"'%d/%m/%Y'",
			"all_",
			"Library",
			"MyBooks()",
			"Library",
			", anchor=tk.CENTER",
			"tk.E",
			"genre",
			"search_genre_tv_BD",
			"genre",
			"_columns_searcher_genre_BD",
			"_columns_searcher_location_BD",
			"genres",
			"genre",
			"width",
			"print",
			"Book ID",
			"my_booksID",
			"OptionMenu",
			"Library",
			"OptionMenu",
			"genre_choice_list",
			"SignIn",
			"Register",
			"signIn",
			"Register",
			"signIn",
			"SignIn",
			"signIn",
			"SignIn",
			"add_genre_var",
			"with",
			"insert",
			"VALUES",
			"user_new_password_var",
			"self.forgotPassword",
			"register_container",
			"bytes_current_pw",
			"password_entry",
			"user_password_var",
			"password_label",
			"password_container",
			"verification_code",
			"code_container",
			"accountVerification",
			"verification_code",
			"create_forgot_password_message",
			"create_message",
			"print",
			"create_message",
			"verification_code",
			"create_message",
			"verification_code",
			"db_hashed_pw",
			"reg_email",
			"verification_code"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "main.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 181721,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								10517
							]
						],
						"settings":
						{
							"auto_name": "#",
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1552.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "create_db.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1258,
						"regions":
						{
						},
						"selection":
						[
							[
								1258,
								1258
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 22.0
	},
	"input":
	{
		"height": 209.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 126.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "Packages/Python/Python.sublime-build",
	"project": "LMS.sublime-project",
	"replace":
	{
		"height": 40.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 202.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
